"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _icons = require("../assets/icons");

var _StringUtil = require("../utils/StringUtil");

var _FooterControl = _interopRequireDefault(require("./FooterControl"));

var _GestureView = _interopRequireWildcard(require("./GestureView"));

var _TipView = _interopRequireDefault(require("./TipView"));

var _MoreControl = _interopRequireDefault(require("./MoreControl"));

var _Theme = require("../utils/Theme");

var _HeaderControl = _interopRequireDefault(require("./HeaderControl"));

var _LineSeekBar = _interopRequireDefault(require("./LineSeekBar"));

var _SpeedControl = _interopRequireDefault(require("./SpeedControl"));

var _PlayButton = _interopRequireDefault(require("./PlayButton"));

var _Loader = _interopRequireDefault(require("./Loader"));

var _ColorUtil = require("../utils/ColorUtil");

var _ComponentUtil = require("../utils/ComponentUtil");

var _PlaylistControl = _interopRequireDefault(require("./PlaylistControl"));

var _expoAv = require("expo-av");

var Brightness = _interopRequireWildcard(require("expo-brightness"));

var _PosterView = _interopRequireDefault(require("./PosterView"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ANIMATION_DURATION = 300;
const USE_NATIVE_DRIVER = false;
const FORWARD_OR_REWIND_DURATION = 10;
const RESIZE_MODES = ['BEST_FIT', 'FIT_TO_SCREEN', 'FILL_TO_SCREEN'];
const RESIZE_MODE_VALUES = ['contain', 'cover', 'stretch'];

const NexenPlayer = /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  var _nexenTheme$tagView, _nexenTheme$tagView2, _nexenTheme$colors, _nexenTheme$tagView3, _nexenTheme$colors2, _nexenTheme$tipView, _nexenTheme$tipView2, _nexenTheme$tipView3, _nexenTheme$colors3, _nexenTheme$tipView4, _nexenTheme$colors4, _nexenTheme$sizes, _nexenTheme$colors5, _nexenTheme$colors6;

  let {
    source: playerSource,
    config: playerConfig,
    playList: playerPlayList,
    style,
    insets,
    theme,
    onBackPress,
    onFullScreenModeUpdate,
    onPlay,
    onPause,
    onStop,
    onSkipNext,
    onSkipBack,
    onVolumeUpdate,
    onBrightnessUpdate,
    onMuteUpdate,
    onRepeatUpdate,
    onSpeedUpdate,
    onPlayListItemSelect,
    onScreenLockUpdate,
    onReload,
    onLoad,
    onError
  } = props;

  const [nexenSource, setNexenSource] = _react.default.useState(playerSource);

  const [nexenConfig, setNexenConfig] = _react.default.useState({
    loaderText: 'Loading...',
    errorText: 'Error...!',
    doubleTapTime: 300,
    controlTimeout: 5000,
    controlHideMode: 'touch',
    layoutMode: 'intermediate',
    posterResizeMode: 'cover',
    resizeMode: 'contain',
    volume: 80,
    brightness: 25,
    playbackSpeed: '1.0',
    muted: false,
    repeat: false,
    autoPlay: false,
    disableOnScreenPlayButton: false,
    disableBack: false,
    disableResizeMode: false,
    disableReload: false,
    disableMore: false,
    disableSkip: false,
    disableStop: false,
    disableVolume: false,
    disableFullscreen: false,
    disablePlayList: false,
    ...playerConfig
  });

  const [trackInfo, setTrackInfo] = _react.default.useState({
    trackTime: 0,
    totalTrackTime: 0,
    cachedTrackTime: 0
  });

  const [playList, setPlayList] = _react.default.useState(playerPlayList);

  const [dimension, setDimension] = _react.default.useState({
    width: 0,
    height: 0
  });

  const [showControl, setShowControl] = _react.default.useState(false);

  const [showSpeedControl, setShowSpeedControl] = _react.default.useState(false);

  const [showPlaylistControl, setShowPlaylistControl] = _react.default.useState(false);

  const [showMoreControl, setShowMoreControl] = _react.default.useState(false);

  const [loading, setLoading] = _react.default.useState(false);

  const [error, setError] = _react.default.useState(false);

  const [locked, setLocked] = _react.default.useState(false);

  const [fullScreen, setFullScreen] = _react.default.useState(false);

  const [paused, setPaused] = _react.default.useState(!(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.autoPlay));

  const [disablePlaylistAndSkip, setDisablePlaylistAndSkip] = _react.default.useState(false);

  const durationTime = _react.default.useRef(0);

  const cachedTime = _react.default.useRef(0);

  const currentTime = _react.default.useRef(0);

  const isSeeking = _react.default.useRef(false);

  const isSliding = _react.default.useRef(false);

  const isSeekable = _react.default.useRef(false);

  const gestureEnabled = _react.default.useRef(false);

  const isStopped = _react.default.useRef(false);

  const isVolumeSeekable = _react.default.useRef(true);

  const isFullscreen = _react.default.useRef(fullScreen);

  const posterDisabled = _react.default.useRef(false);

  const showPoster = _react.default.useRef(true);

  const moreControlRef = _react.default.useRef(null);

  const speedControlRef = _react.default.useRef(null);

  const playlistControlRef = _react.default.useRef(null);

  const videoRef = _react.default.useRef(null);

  const tipViewRef = _react.default.useRef(null);

  const headerControlRef = _react.default.useRef(null);

  const footerControlRef = _react.default.useRef(null);

  const headerOpacity = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const headerTopMargin = _react.default.useRef(new _reactNative.Animated.Value(-60)).current;

  const footerOpacity = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const footerBottomMargin = _react.default.useRef(new _reactNative.Animated.Value(-60)).current;

  const controlTimeoutRef = _react.default.useRef(null);

  _react.default.useImperativeHandle(ref, () => ({
    play: () => {
      setPaused(false);
    },
    pause: () => {
      setPaused(true);
    },
    stop: () => {
      handleStopPlayback();
    },
    skipNext: () => {
      _onSkipNext();
    },
    skipBack: () => {
      _onSkipBack();
    },
    reload: callback => {
      handleReloadVideo(() => {
        callback === null || callback === void 0 ? void 0 : callback();
        onReload === null || onReload === void 0 ? void 0 : onReload(nexenConfig ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
      });
    },
    load: (index, callback) => {
      handleLoadVideo(index, () => {
        callback === null || callback === void 0 ? void 0 : callback();
      });
    },
    setFullScreenMode: fullScreen => {
      setFullScreen(fullScreen);
      onFullScreenModeUpdate === null || onFullScreenModeUpdate === void 0 ? void 0 : onFullScreenModeUpdate(fullScreen, nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
    }
  }));

  const nexenTheme = _react.default.useMemo(() => {
    return { ..._Theme.DefaultTheme,
      trackSeekBar: { ..._Theme.DefaultTheme.trackSeekBar,
        ...(theme === null || theme === void 0 ? void 0 : theme.trackSeekBar)
      },
      speedSeekBar: { ..._Theme.DefaultTheme.speedSeekBar,
        ...(theme === null || theme === void 0 ? void 0 : theme.speedSeekBar)
      },
      lineSeekBar: { ..._Theme.DefaultTheme.lineSeekBar,
        ...(theme === null || theme === void 0 ? void 0 : theme.lineSeekBar)
      },
      miniSeekBar: { ..._Theme.DefaultMiniSeekBarTheme,
        ...(theme === null || theme === void 0 ? void 0 : theme.miniSeekBar)
      },
      volumeSeekBar: { ..._Theme.DefaultTheme.volumeSeekBar,
        ...(theme === null || theme === void 0 ? void 0 : theme.volumeSeekBar)
      },
      brightnessSeekBar: { ..._Theme.DefaultTheme.brightnessSeekBar,
        ...(theme === null || theme === void 0 ? void 0 : theme.brightnessSeekBar)
      },
      lockButton: { ..._Theme.DefaultTheme.lockButton,
        ...(theme === null || theme === void 0 ? void 0 : theme.lockButton)
      },
      tagView: { ..._Theme.DefaultTagViewTheme,
        ...(theme === null || theme === void 0 ? void 0 : theme.tagView)
      },
      colors: { ..._Theme.DefaultTheme.colors,
        ...(theme === null || theme === void 0 ? void 0 : theme.colors)
      },
      sizes: { ..._Theme.DefaultSizesTheme,
        ...(theme === null || theme === void 0 ? void 0 : theme.sizes)
      },
      fonts: { ...(theme === null || theme === void 0 ? void 0 : theme.fonts)
      }
    };
  }, [theme]);

  const ICON_SIZE_FACTOR = 0.8;
  const TAG_VIEW_ICON_SIZE = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView = nexenTheme.tagView) === null || _nexenTheme$tagView === void 0 ? void 0 : _nexenTheme$tagView.iconSize;
  const TAG_VIEW_ACTIVE_ICON_COLOR = (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView2 = nexenTheme.tagView) === null || _nexenTheme$tagView2 === void 0 ? void 0 : _nexenTheme$tagView2.activeIconColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors = nexenTheme.colors) === null || _nexenTheme$colors === void 0 ? void 0 : _nexenTheme$colors.accentColor, 0.7);
  const TAG_VIEW_INACTIVE_ICON_COLOR = (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView3 = nexenTheme.tagView) === null || _nexenTheme$tagView3 === void 0 ? void 0 : _nexenTheme$tagView3.inactiveIconColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors2 = nexenTheme.colors) === null || _nexenTheme$colors2 === void 0 ? void 0 : _nexenTheme$colors2.primaryColor, 0.5);
  const TIP_VIEW_ICON_SIZE = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView = nexenTheme.tipView) === null || _nexenTheme$tipView === void 0 ? void 0 : _nexenTheme$tipView.iconSize;
  const TIP_VIEW_TEXT_SIZE = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView2 = nexenTheme.tipView) === null || _nexenTheme$tipView2 === void 0 ? void 0 : _nexenTheme$tipView2.textSize;
  const TIP_VIEW_ICON_COLOR = ((_nexenTheme$tipView3 = nexenTheme.tipView) === null || _nexenTheme$tipView3 === void 0 ? void 0 : _nexenTheme$tipView3.iconColor) || ((_nexenTheme$colors3 = nexenTheme.colors) === null || _nexenTheme$colors3 === void 0 ? void 0 : _nexenTheme$colors3.secondaryIconColor);
  const TIP_VIEW_TEXT_COLOR = (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView4 = nexenTheme.tipView) === null || _nexenTheme$tipView4 === void 0 ? void 0 : _nexenTheme$tipView4.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors4 = nexenTheme.colors) === null || _nexenTheme$colors4 === void 0 ? void 0 : _nexenTheme$colors4.secondaryTextColor);
  const CONTAINER_BORDER_RADIUS = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes = nexenTheme.sizes) === null || _nexenTheme$sizes === void 0 ? void 0 : _nexenTheme$sizes.modalCornerRadius;
  const CONTAINER_BACKGROUND_COLOR = (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors5 = nexenTheme.colors) === null || _nexenTheme$colors5 === void 0 ? void 0 : _nexenTheme$colors5.modalBackgroundColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors6 = nexenTheme.colors) === null || _nexenTheme$colors6 === void 0 ? void 0 : _nexenTheme$colors6.primaryColor, 0.7);
  const minValue = Math.min(Number(dimension.width), Number(dimension.height));
  const MORE_CONTROL_CONTAINER_WIDTH = fullScreen ? minValue * 0.55 + (insets === null || insets === void 0 ? void 0 : insets.right) : minValue * 0.7;
  const SPEED_CONTROL_CONTAINER_HEIGHT = fullScreen ? minValue * 0.2 + (insets === null || insets === void 0 ? void 0 : insets.bottom) : minValue * 0.3;
  const PLAYLIST_CONTROL_CONTAINER_HEIGHT = fullScreen ? minValue * 0.3 + (insets === null || insets === void 0 ? void 0 : insets.bottom) : minValue * 0.35;
  const LINE_SEEK_BAR_HEIGHT = 2;

  const rtlMultiplier = _react.default.useRef(1);

  const isRTL = _reactNative.I18nManager.isRTL;
  rtlMultiplier.current = isRTL ? -1 : 1;

  const tipViewTheme = _react.default.useMemo(() => {
    var _nexenTheme$fonts;

    return {
      textColor: TIP_VIEW_TEXT_COLOR,
      textSize: TIP_VIEW_TEXT_SIZE,
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts = nexenTheme.fonts) === null || _nexenTheme$fonts === void 0 ? void 0 : _nexenTheme$fonts.secondaryFont
    };
  }, [nexenTheme]);

  const loaderTheme = _react.default.useMemo(() => {
    var _nexenTheme$fonts2;

    return {
      iconSize: 40,
      iconColor: TIP_VIEW_ICON_COLOR,
      textColor: TIP_VIEW_TEXT_COLOR,
      textSize: 16,
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts2 = nexenTheme.fonts) === null || _nexenTheme$fonts2 === void 0 ? void 0 : _nexenTheme$fonts2.secondaryFont
    };
  }, [nexenTheme]);

  const lineSeekBarTheme = _react.default.useMemo(() => {
    var _nexenTheme$lineSeekB, _nexenTheme$colors7, _nexenTheme$lineSeekB2, _nexenTheme$colors8;

    return {
      lineHeight: LINE_SEEK_BAR_HEIGHT,
      lineColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$lineSeekB = nexenTheme.lineSeekBar) === null || _nexenTheme$lineSeekB === void 0 ? void 0 : _nexenTheme$lineSeekB.lineColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors7 = nexenTheme.colors) === null || _nexenTheme$colors7 === void 0 ? void 0 : _nexenTheme$colors7.accentColor),
      lineUnderlayColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$lineSeekB2 = nexenTheme.lineSeekBar) === null || _nexenTheme$lineSeekB2 === void 0 ? void 0 : _nexenTheme$lineSeekB2.lineUnderlayColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors8 = nexenTheme.colors) === null || _nexenTheme$colors8 === void 0 ? void 0 : _nexenTheme$colors8.secondaryColor, 0.3)
    };
  }, [nexenTheme]);

  const _onLayoutChange = async e => {
    const {
      width,
      height
    } = e.nativeEvent.layout;
    const {
      width: w,
      height: h
    } = dimension;

    if (w !== width || h !== height) {
      setDimension({
        width,
        height
      }); // console.log(`onLayoutChange:: width: ${width} height: ${height}`);
    }
  };

  const _onTapDetected = _react.default.useCallback(async (event, value) => {
    switch (event) {
      case _GestureView.TapEventType.SINGLE_TAP:
        if (showMoreControl) {
          hideMoreOptions();
          gestureEnabled.current = true;
          break;
        }

        if (showSpeedControl) {
          hidePlaybackSpeedControl();
          gestureEnabled.current = true;
          break;
        }

        if (showPlaylistControl) {
          hideVideoListControl();
          gestureEnabled.current = true;
          break;
        }

        if (showControl) {
          hideMainControl();
        } else {
          showMainControl();
        }

        break;

      case _GestureView.TapEventType.DOUBLE_TAP_LEFT:
      case _GestureView.TapEventType.DOUBLE_TAP_RIGHT:
        if (value) {
          var _videoRef$current;

          await ((_videoRef$current = videoRef.current) === null || _videoRef$current === void 0 ? void 0 : _videoRef$current.setStatusAsync({
            positionMillis: value * 1000
          }));
          setTrackInfo(prevState => {
            return { ...prevState,
              trackTime: value
            };
          });
        }

        break;

      case _GestureView.TapEventType.DOUBLE_TAP_MIDDLE:
        handleDoubleTapPlayPause();
        break;
    }
  }, [showControl, showMoreControl, showSpeedControl, showPlaylistControl, paused]);

  const _onGestureMove = _react.default.useCallback((event, value) => {
    var _headerControlRef$cur, _videoRef$current2, _headerControlRef$cur2;

    switch (event) {
      case _GestureView.GestureEventType.VOLUME:
        (_headerControlRef$cur = headerControlRef.current) === null || _headerControlRef$cur === void 0 ? void 0 : _headerControlRef$cur.updateIconTagView({
          volumeIcon: (0, _ComponentUtil.getVolumeIcon)(value, _GestureView.MAX_VOLUME, TAG_VIEW_ICON_SIZE, TIP_VIEW_ICON_COLOR)
        });
        (_videoRef$current2 = videoRef.current) === null || _videoRef$current2 === void 0 ? void 0 : _videoRef$current2.setStatusAsync({
          volume: value / 100
        });
        onVolumeUpdate === null || onVolumeUpdate === void 0 ? void 0 : onVolumeUpdate(value);
        break;

      case _GestureView.GestureEventType.BRIGHTNESS:
        (_headerControlRef$cur2 = headerControlRef.current) === null || _headerControlRef$cur2 === void 0 ? void 0 : _headerControlRef$cur2.updateIconTagView({
          brightnessIcon: (0, _ComponentUtil.getBrightnessIcon)(value, _GestureView.MAX_BRIGHTNESS, TAG_VIEW_ICON_SIZE, TIP_VIEW_ICON_COLOR)
        });
        Brightness.setBrightnessAsync(value / 100);
        onBrightnessUpdate === null || onBrightnessUpdate === void 0 ? void 0 : onBrightnessUpdate(value);
        break;
    }
  }, []);

  const _onGestureEnd = _react.default.useCallback(async (event, value) => {
    var _videoRef$current3, _headerControlRef$cur3, _videoRef$current4, _headerControlRef$cur4;

    switch (event) {
      case _GestureView.GestureEventType.TRACK:
        (_videoRef$current3 = videoRef.current) === null || _videoRef$current3 === void 0 ? void 0 : _videoRef$current3.setStatusAsync({
          positionMillis: value * 1000
        });
        setTrackInfo(prevState => {
          return { ...prevState,
            trackTime: value
          };
        });
        break;

      case _GestureView.GestureEventType.VOLUME:
        (_headerControlRef$cur3 = headerControlRef.current) === null || _headerControlRef$cur3 === void 0 ? void 0 : _headerControlRef$cur3.updateIconTagView({
          volumeIcon: (0, _ComponentUtil.getVolumeIcon)(value, _GestureView.MAX_VOLUME, TAG_VIEW_ICON_SIZE, TIP_VIEW_ICON_COLOR)
        });
        (_videoRef$current4 = videoRef.current) === null || _videoRef$current4 === void 0 ? void 0 : _videoRef$current4.setStatusAsync({
          volume: value / 100
        });
        setNexenConfig(prevState => {
          return { ...prevState,
            volume: value
          };
        });
        onVolumeUpdate === null || onVolumeUpdate === void 0 ? void 0 : onVolumeUpdate(value);
        break;

      case _GestureView.GestureEventType.BRIGHTNESS:
        (_headerControlRef$cur4 = headerControlRef.current) === null || _headerControlRef$cur4 === void 0 ? void 0 : _headerControlRef$cur4.updateIconTagView({
          brightnessIcon: (0, _ComponentUtil.getBrightnessIcon)(value, _GestureView.MAX_BRIGHTNESS, TAG_VIEW_ICON_SIZE, TIP_VIEW_ICON_COLOR)
        });
        Brightness.setBrightnessAsync(value / 100);
        setNexenConfig(prevState => {
          return { ...prevState,
            brightness: value
          };
        });
        onBrightnessUpdate === null || onBrightnessUpdate === void 0 ? void 0 : onBrightnessUpdate(value);
        break;
    }
  }, []);

  const showMainControl = () => {
    setShowControl(true);
  };

  const hideMainControl = () => {
    startControlHideAnimation(() => {
      setShowControl(false);
    });
  };

  const setControlTimeout = () => {
    controlTimeoutRef.current = setTimeout(() => {
      hideMainControl();
    }, nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.controlTimeout);
  };

  const clearControlTimeout = () => {
    if (controlTimeoutRef.current) {
      clearTimeout(controlTimeoutRef.current);
    }
  };

  const resetControlTimeout = () => {
    clearControlTimeout();
    setControlTimeout();
  };

  const showMoreOptions = () => {
    setShowMoreControl(true);
  };

  const hideMoreOptions = () => {
    var _moreControlRef$curre;

    (_moreControlRef$curre = moreControlRef.current) === null || _moreControlRef$curre === void 0 ? void 0 : _moreControlRef$curre.hide(() => {
      setShowMoreControl(false);
    });
  };

  const showPlaybackSpeedControl = () => {
    setShowSpeedControl(true);
  };

  const hidePlaybackSpeedControl = () => {
    var _speedControlRef$curr;

    (_speedControlRef$curr = speedControlRef.current) === null || _speedControlRef$curr === void 0 ? void 0 : _speedControlRef$curr.hide(() => {
      setShowSpeedControl(false);
    });
  };

  const showVideoListControl = () => {
    setShowPlaylistControl(true);
  };

  const hideVideoListControl = () => {
    var _playlistControlRef$c;

    (_playlistControlRef$c = playlistControlRef.current) === null || _playlistControlRef$c === void 0 ? void 0 : _playlistControlRef$c.hide(() => {
      setShowPlaylistControl(false);
    });
  };

  const startControlShowAnimation = callback => {
    _reactNative.Animated.parallel([_reactNative.Animated.timing(headerOpacity, {
      toValue: 1,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    }), _reactNative.Animated.timing(headerTopMargin, {
      toValue: 0,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    }), _reactNative.Animated.timing(footerOpacity, {
      toValue: 1,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    }), _reactNative.Animated.timing(footerBottomMargin, {
      toValue: 0,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    })]).start(callback);
  };

  const startControlHideAnimation = callback => {
    _reactNative.Animated.parallel([_reactNative.Animated.timing(headerOpacity, {
      toValue: 0,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    }), _reactNative.Animated.timing(headerTopMargin, {
      toValue: -60,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    }), _reactNative.Animated.timing(footerOpacity, {
      toValue: 0,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    }), _reactNative.Animated.timing(footerBottomMargin, {
      toValue: -60,
      duration: ANIMATION_DURATION,
      useNativeDriver: USE_NATIVE_DRIVER
    })]).start(callback);
  };

  _react.default.useEffect(() => {
    if (paused) {
      onPause === null || onPause === void 0 ? void 0 : onPause(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
    } else {
      onPlay === null || onPlay === void 0 ? void 0 : onPlay(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
    }
  }, [paused]);

  _react.default.useEffect(() => {
    isFullscreen.current = fullScreen;

    if (showControl) {
      startControlShowAnimation();

      if ((nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.controlHideMode) == 'auto') {
        setControlTimeout();
      }
    } else {
      if ((nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.controlHideMode) == 'auto') {
        clearControlTimeout();
      }
    }

    if ((nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.layoutMode) === 'advanced') {
      var _headerControlRef$cur5;

      (_headerControlRef$cur5 = headerControlRef.current) === null || _headerControlRef$cur5 === void 0 ? void 0 : _headerControlRef$cur5.updateIconTagView({
        volumeIcon: (0, _ComponentUtil.getVolumeIcon)(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.volume, _GestureView.MAX_VOLUME, TAG_VIEW_ICON_SIZE, TIP_VIEW_ICON_COLOR),
        brightnessIcon: (0, _ComponentUtil.getBrightnessIcon)(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.brightness, _GestureView.MAX_BRIGHTNESS, TAG_VIEW_ICON_SIZE, TIP_VIEW_ICON_COLOR),
        repeatIcon: nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.repeat ? /*#__PURE__*/_react.default.createElement(_icons.IconRepeat, {
          size: TAG_VIEW_ICON_SIZE,
          color: TAG_VIEW_ACTIVE_ICON_COLOR
        }) : /*#__PURE__*/_react.default.createElement(_icons.IconRepeat, {
          size: TAG_VIEW_ICON_SIZE,
          color: TAG_VIEW_INACTIVE_ICON_COLOR
        }),
        speedIcon: (nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.playbackSpeed) !== '1.0' ? /*#__PURE__*/_react.default.createElement(_icons.IconZap, {
          size: TAG_VIEW_ICON_SIZE,
          color: TAG_VIEW_ACTIVE_ICON_COLOR
        }) : /*#__PURE__*/_react.default.createElement(_icons.IconZap, {
          size: TAG_VIEW_ICON_SIZE,
          color: TAG_VIEW_INACTIVE_ICON_COLOR
        })
      });
    }
  }, [showControl, fullScreen, locked, nexenConfig]);

  _react.default.useEffect(() => {
    if (showMoreControl) {
      var _moreControlRef$curre2;

      (_moreControlRef$curre2 = moreControlRef.current) === null || _moreControlRef$curre2 === void 0 ? void 0 : _moreControlRef$curre2.show();
      return;
    }

    if (showSpeedControl) {
      var _speedControlRef$curr2;

      (_speedControlRef$curr2 = speedControlRef.current) === null || _speedControlRef$curr2 === void 0 ? void 0 : _speedControlRef$curr2.show();
      return;
    }

    if (showPlaylistControl) {
      var _playlistControlRef$c2;

      (_playlistControlRef$c2 = playlistControlRef.current) === null || _playlistControlRef$c2 === void 0 ? void 0 : _playlistControlRef$c2.show();
      return;
    }
  }, [showMoreControl, showSpeedControl, showPlaylistControl]);

  _react.default.useEffect(() => {
    currentTime.current = trackInfo.trackTime;
    cachedTime.current = trackInfo.cachedTrackTime;
    durationTime.current = trackInfo.totalTrackTime;
  }, [trackInfo]);

  _react.default.useEffect(() => {
    const currentIndex = RESIZE_MODE_VALUES.indexOf(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.resizeMode);

    if (isSeekable.current) {
      var _tipViewRef$current;

      (_tipViewRef$current = tipViewRef.current) === null || _tipViewRef$current === void 0 ? void 0 : _tipViewRef$current.updateState({
        showTip: true,
        tipText: (0, _StringUtil.getAspectRatioTipText)(RESIZE_MODES[currentIndex]),
        autoHide: true
      });
    }
  }, [nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.resizeMode]); // React.useEffect(() => {
  //   if (playerSource.poster) {
  //     setShowPoster(true);
  //   } else {
  //     setShowPoster(false);
  //   }
  // }, [playerSource.poster]);


  _react.default.useEffect(() => {
    const newConfig = { ...nexenConfig,
      ...playerConfig
    };
    Brightness.setBrightnessAsync(newConfig.brightness / 100);
    setNexenConfig(newConfig);

    if (newConfig !== null && newConfig !== void 0 && newConfig.optimize) {
      if ((newConfig === null || newConfig === void 0 ? void 0 : newConfig.index) != (newConfig === null || newConfig === void 0 ? void 0 : newConfig.activeIndex)) {
        showPoster.current = true;
        setPaused(true);
        hideMainControl();
      } else {
        setPlayList(prevState => {
          return { ...prevState,
            currentIndex: newConfig === null || newConfig === void 0 ? void 0 : newConfig.activeIndex
          };
        });
      }
    }
  }, [playerConfig]);

  _react.default.useEffect(() => {
    const newSource = { ...nexenSource,
      ...playerSource
    };

    if (newSource.poster) {
      showPoster.current = true;
    } else {
      showPoster.current = false;
    }

    setNexenSource(newSource);
  }, [playerSource]);

  _react.default.useEffect(() => {
    if (!playerPlayList || !playerPlayList.items || playerPlayList.items.length === 0) {
      setDisablePlaylistAndSkip(true);
    } else {
      setDisablePlaylistAndSkip(false);
    }

    setPlayList(playerPlayList); // setPlayList((prevState) => {
    //   return {
    //     ...prevState,
    //     ...playerPlayList,
    //   };
    // });
  }, [playerPlayList]); // React.useEffect(() => {
  //   if (optimizationConfig?.optimize) {
  //     if (optimizationConfig?.index != optimizationConfig?.activeIndex) {
  //       setShowPoster(true);
  //       setPaused(true);
  //       hideMainControl();
  //     } else {
  //       // setPlaylistIndex(optimizationConfig?.activeIndex!);
  //       playlistIndex.current = optimizationConfig?.activeIndex!;
  //     }
  //   }
  // }, [optimizationConfig]);


  _react.default.useEffect(() => {
    const backHandler = _reactNative.BackHandler.addEventListener('hardwareBackPress', _onBackPress);

    return () => {
      if (backHandler) {
        backHandler.remove();
      }

      if (controlTimeoutRef.current) {
        clearTimeout(controlTimeoutRef.current);
      }
    };
  }, []);

  const _onBackPress = _react.default.useCallback(() => {
    if (isFullscreen.current) {
      setFullScreen(false);
      onFullScreenModeUpdate === null || onFullScreenModeUpdate === void 0 ? void 0 : onFullScreenModeUpdate(false, nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
    } else {
      onBackPress === null || onBackPress === void 0 ? void 0 : onBackPress();
    }

    return true;
  }, []);

  const _onAspectRatioPress = _react.default.useCallback(() => {
    handleResizeMode(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.resizeMode);
  }, [nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.resizeMode]);

  const _onMorePress = _react.default.useCallback(() => {
    showMoreOptions();
    hideMainControl();
    gestureEnabled.current = false;
  }, []);

  const _onMoreItemPress = _react.default.useCallback(item => {
    switch (item.id) {
      case 'lock':
        hideMoreOptions();
        handleLockScreen();
        isSeekable.current = false;
        gestureEnabled.current = false;
        break;

      case 'speed':
        hideMoreOptions();
        showPlaybackSpeedControl();
        gestureEnabled.current = false;
        break;

      case 'repeat':
        hideMoreOptions();
        handleRepeatVideo(!(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.repeat));
        gestureEnabled.current = true;
        break;

      case 'reload':
        hideMoreOptions();
        handleReloadVideo();
        gestureEnabled.current = true;
        break;

      case 'playlist':
        hideMoreOptions();
        showVideoListControl();
        gestureEnabled.current = false;
        break;
    }
  }, [paused, nexenConfig]);

  const _onSpeedUpdate = _react.default.useCallback(value => {
    var _tipViewRef$current2;

    // const newSpeed = Number(value);
    const newSpeed = value;
    (_tipViewRef$current2 = tipViewRef.current) === null || _tipViewRef$current2 === void 0 ? void 0 : _tipViewRef$current2.updateState({
      showTip: true,
      tipText: `${newSpeed}x Speed`,
      autoHide: true,
      withIcon: true,
      icon: /*#__PURE__*/_react.default.createElement(_icons.IconZap, {
        size: TIP_VIEW_ICON_SIZE,
        color: TIP_VIEW_ICON_COLOR
      })
    });
    setNexenConfig(prevState => {
      return { ...prevState,
        playbackSpeed: newSpeed
      };
    });
    onSpeedUpdate === null || onSpeedUpdate === void 0 ? void 0 : onSpeedUpdate(newSpeed);
  }, []);

  const handleDoubleTapPlayPause = () => {
    if (paused) {
      var _tipViewRef$current3;

      setPaused(false);
      (_tipViewRef$current3 = tipViewRef.current) === null || _tipViewRef$current3 === void 0 ? void 0 : _tipViewRef$current3.updateState({
        showTip: true,
        tipText: 'Playing',
        autoHide: true,
        withIcon: true,
        icon: /*#__PURE__*/_react.default.createElement(_icons.IconPaly, {
          size: TIP_VIEW_ICON_SIZE,
          color: TIP_VIEW_ICON_COLOR
        })
      });
    } else {
      var _tipViewRef$current4;

      setPaused(true);
      (_tipViewRef$current4 = tipViewRef.current) === null || _tipViewRef$current4 === void 0 ? void 0 : _tipViewRef$current4.updateState({
        showTip: true,
        tipText: 'Paused',
        autoHide: true,
        withIcon: true,
        icon: /*#__PURE__*/_react.default.createElement(_icons.IconPause, {
          size: TIP_VIEW_ICON_SIZE,
          color: TIP_VIEW_ICON_COLOR
        })
      });
    }
  };
  /* FooterControl Callback */


  const _onPlayButtonPress = () => {
    setPaused(false);
  };

  const _onStopPress = () => {
    handleStopPlayback();
  };

  const _onReloadPress = () => {
    handleReloadVideo();
  };

  const handleStopPlayback = () => {
    var _videoRef$current5;

    isStopped.current = true;
    (_videoRef$current5 = videoRef.current) === null || _videoRef$current5 === void 0 ? void 0 : _videoRef$current5.setStatusAsync({
      positionMillis: 0
    });
    setPaused(true);
    onStop === null || onStop === void 0 ? void 0 : onStop(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
  };

  const handleRepeatVideo = repeat => {
    var _tipViewRef$current5;

    (_tipViewRef$current5 = tipViewRef.current) === null || _tipViewRef$current5 === void 0 ? void 0 : _tipViewRef$current5.updateState({
      showTip: true,
      tipText: repeat ? 'Repeat On' : 'Repeat Off',
      autoHide: true,
      withIcon: true,
      icon: /*#__PURE__*/_react.default.createElement(_icons.IconRepeat, {
        size: TIP_VIEW_ICON_SIZE,
        color: TIP_VIEW_ICON_COLOR
      })
    });
    setNexenConfig(prevState => {
      return { ...prevState,
        repeat: repeat
      };
    });
    onRepeatUpdate === null || onRepeatUpdate === void 0 ? void 0 : onRepeatUpdate(repeat); // setLoop((prevState) => !prevState);
  };

  const handleReloadVideo = callback => {
    handleUnloadVideo(() => {
      var _videoRef$current6;

      (_videoRef$current6 = videoRef.current) === null || _videoRef$current6 === void 0 ? void 0 : _videoRef$current6.loadAsync(playList !== null && playList !== void 0 && playList.items ? (playList === null || playList === void 0 ? void 0 : playList.items.length) !== 0 ? playList === null || playList === void 0 ? void 0 : playList.items[playList === null || playList === void 0 ? void 0 : playList.currentIndex].itemSource : nexenSource.source : nexenSource.source).then(() => {
        callback === null || callback === void 0 ? void 0 : callback();
      });
    });
  };

  const handleUnloadVideo = callback => {
    var _videoRef$current7;

    (_videoRef$current7 = videoRef.current) === null || _videoRef$current7 === void 0 ? void 0 : _videoRef$current7.unloadAsync().then(() => {
      setTrackInfo({
        trackTime: 0,
        totalTrackTime: 0,
        cachedTrackTime: 0
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  };

  const handleLoadVideo = (index, callback) => {
    handleUnloadVideo(() => {
      setPlayList(prevState => {
        return { ...prevState,
          currentIndex: index
        };
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  };

  const handleLoadPlayListVideo = (index, callback) => {
    var _videoRef$current8;

    (_videoRef$current8 = videoRef.current) === null || _videoRef$current8 === void 0 ? void 0 : _videoRef$current8.unloadAsync().then(() => {
      setTrackInfo({
        trackTime: 0,
        totalTrackTime: 0,
        cachedTrackTime: 0
      });
      setPlayList(prevState => {
        return { ...prevState,
          currentIndex: index
        };
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  };

  const handleLockScreen = () => {
    var _tipViewRef$current6;

    (_tipViewRef$current6 = tipViewRef.current) === null || _tipViewRef$current6 === void 0 ? void 0 : _tipViewRef$current6.updateState({
      showTip: true,
      tipText: 'Locked',
      autoHide: true,
      withIcon: true,
      icon: /*#__PURE__*/_react.default.createElement(_icons.IconLock, {
        size: TIP_VIEW_ICON_SIZE,
        color: TIP_VIEW_ICON_COLOR
      })
    });
    setLocked(true);
    onScreenLockUpdate === null || onScreenLockUpdate === void 0 ? void 0 : onScreenLockUpdate(true);
  };

  const handleResizeMode = resizeMode => {
    const currentIndex = RESIZE_MODE_VALUES.indexOf(resizeMode);

    if (currentIndex < RESIZE_MODE_VALUES.length - 1) {
      setNexenConfig(prevState => {
        return { ...prevState,
          resizeMode: RESIZE_MODE_VALUES[currentIndex + 1]
        };
      });
    } else {
      setNexenConfig(prevState => {
        return { ...prevState,
          resizeMode: RESIZE_MODE_VALUES[0]
        };
      });
    }
  };

  const _onRewind = () => {
    var _videoRef$current9;

    const time = trackInfo.trackTime - FORWARD_OR_REWIND_DURATION;
    (_videoRef$current9 = videoRef.current) === null || _videoRef$current9 === void 0 ? void 0 : _videoRef$current9.setStatusAsync({
      positionMillis: time * 1000
    });
    setTrackInfo(prevState => {
      return { ...prevState,
        trackTime: time
      };
    });
  };

  const _onFastForward = () => {
    var _videoRef$current10;

    const time = trackInfo.trackTime + FORWARD_OR_REWIND_DURATION;
    (_videoRef$current10 = videoRef.current) === null || _videoRef$current10 === void 0 ? void 0 : _videoRef$current10.setStatusAsync({
      positionMillis: time * 1000
    });
    setTrackInfo(prevState => {
      return { ...prevState,
        trackTime: time
      };
    });
  };

  const _onSkipNext = () => {
    if (playList) {
      var _playList$items;

      if (playList.currentIndex >= 0 && playList.currentIndex < ((_playList$items = playList.items) === null || _playList$items === void 0 ? void 0 : _playList$items.length) - 1) {
        const index = (playList === null || playList === void 0 ? void 0 : playList.currentIndex) + 1;
        handleLoadPlayListVideo(index, () => {
          onSkipNext === null || onSkipNext === void 0 ? void 0 : onSkipNext(index);
        });
      }
    }
  };

  const _onSkipBack = () => {
    if (playList) {
      var _playList$items2;

      if (playList.currentIndex >= 0 && playList.currentIndex < ((_playList$items2 = playList.items) === null || _playList$items2 === void 0 ? void 0 : _playList$items2.length) - 1) {
        const index = playList.currentIndex - 1;
        handleLoadPlayListVideo(index, () => {
          onSkipBack === null || onSkipBack === void 0 ? void 0 : onSkipBack(index);
        });
      }
    }
  };

  const _onPlaylistItemPress = index => {
    if (playList) {
      if (playList.currentIndex !== index) {
        handleLoadPlayListVideo(index, () => {
          onPlayListItemSelect === null || onPlayListItemSelect === void 0 ? void 0 : onPlayListItemSelect(index);
        });
      }
    }
  };

  const _onTogglePlayPause = () => {
    setPaused(prevState => !prevState);
  };

  const _onToggleFullScreen = () => {
    onFullScreenModeUpdate === null || onFullScreenModeUpdate === void 0 ? void 0 : onFullScreenModeUpdate(!fullScreen, nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
    setFullScreen(prevState => !prevState);
  };

  const _onToggleVolume = () => {
    handleMuteVideo(!(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.muted));
  };

  const handleMuteVideo = mute => {
    var _tipViewRef$current7;

    (_tipViewRef$current7 = tipViewRef.current) === null || _tipViewRef$current7 === void 0 ? void 0 : _tipViewRef$current7.updateState({
      showTip: true,
      tipText: mute ? 'Sound Off' : 'Sound On',
      autoHide: true
    });
    isVolumeSeekable.current = !mute;
    setNexenConfig(prevState => {
      return { ...prevState,
        muted: mute
      };
    });
    onMuteUpdate === null || onMuteUpdate === void 0 ? void 0 : onMuteUpdate(mute);
  };
  /* Slide Button Callback */


  const _onSlideStart = _react.default.useCallback(() => {
    isSliding.current = true;
  }, []);

  const _onSlideEnd = _react.default.useCallback(() => {
    isSliding.current = false;
  }, []);

  const _onReachedToStart = _react.default.useCallback(() => {}, []);

  const _onReachedToEnd = _react.default.useCallback(() => {
    var _tipViewRef$current8;

    setLocked(false);
    isSeekable.current = true;
    gestureEnabled.current = true;
    (_tipViewRef$current8 = tipViewRef.current) === null || _tipViewRef$current8 === void 0 ? void 0 : _tipViewRef$current8.updateState({
      showTip: true,
      tipText: 'Unlocked',
      autoHide: true,
      withIcon: true,
      icon: /*#__PURE__*/_react.default.createElement(_icons.IconUnlock, {
        size: TIP_VIEW_ICON_SIZE,
        color: TIP_VIEW_ICON_COLOR
      })
    });
    onScreenLockUpdate === null || onScreenLockUpdate === void 0 ? void 0 : onScreenLockUpdate(false);
  }, []);
  /* SeekBar Callback */


  const _onSeekStart = _react.default.useCallback((value, totalValue) => {
    var _tipViewRef$current9;

    isSeeking.current = true;
    (_tipViewRef$current9 = tipViewRef.current) === null || _tipViewRef$current9 === void 0 ? void 0 : _tipViewRef$current9.updateState({
      showTip: true,
      tipText: (0, _StringUtil.getTimeTipText)(value, totalValue),
      autoHide: false
    });
  }, []);

  const _onSeekUpdate = _react.default.useCallback((value, totalValue) => {
    if (isSeeking.current) {
      var _tipViewRef$current10;

      (_tipViewRef$current10 = tipViewRef.current) === null || _tipViewRef$current10 === void 0 ? void 0 : _tipViewRef$current10.updateState({
        tipText: (0, _StringUtil.getTimeTipText)(value, totalValue)
      });
    }
  }, []);

  const _onSeekEnd = _react.default.useCallback(value => {
    var _videoRef$current11, _tipViewRef$current11;

    isSeeking.current = false;
    (_videoRef$current11 = videoRef.current) === null || _videoRef$current11 === void 0 ? void 0 : _videoRef$current11.setStatusAsync({
      positionMillis: value * 1000
    });
    setTrackInfo(prevState => {
      return { ...prevState,
        trackTime: value
      };
    });
    (_tipViewRef$current11 = tipViewRef.current) === null || _tipViewRef$current11 === void 0 ? void 0 : _tipViewRef$current11.updateState({
      showTip: false,
      autoHide: true
    });
  }, []);
  /* Volume SeekBar Callback */


  const _onVolumeSeekStart = _react.default.useCallback(async (value, totalValue) => {
    var _tipViewRef$current12, _videoRef$current12;

    (_tipViewRef$current12 = tipViewRef.current) === null || _tipViewRef$current12 === void 0 ? void 0 : _tipViewRef$current12.updateState({
      showTip: true,
      tipText: `Volume : ${value}%`,
      autoHide: false
    });
    (_videoRef$current12 = videoRef.current) === null || _videoRef$current12 === void 0 ? void 0 : _videoRef$current12.setStatusAsync({
      volume: value / 100
    });
    onVolumeUpdate === null || onVolumeUpdate === void 0 ? void 0 : onVolumeUpdate(value);
  }, []);

  const _onVolumeSeekUpdate = _react.default.useCallback(async (value, totalValue) => {
    var _tipViewRef$current13, _videoRef$current13;

    (_tipViewRef$current13 = tipViewRef.current) === null || _tipViewRef$current13 === void 0 ? void 0 : _tipViewRef$current13.updateState({
      showTip: true,
      tipText: `Volume : ${value}%`,
      autoHide: false
    });
    (_videoRef$current13 = videoRef.current) === null || _videoRef$current13 === void 0 ? void 0 : _videoRef$current13.setStatusAsync({
      volume: value / 100
    });
    onVolumeUpdate === null || onVolumeUpdate === void 0 ? void 0 : onVolumeUpdate(value);
  }, []);

  const _onVolumeSeekEnd = _react.default.useCallback(async value => {
    var _tipViewRef$current14;

    setNexenConfig(prevState => {
      return { ...prevState,
        volume: value
      };
    });
    (_tipViewRef$current14 = tipViewRef.current) === null || _tipViewRef$current14 === void 0 ? void 0 : _tipViewRef$current14.updateState({
      showTip: false,
      autoHide: true
    });
    onVolumeUpdate === null || onVolumeUpdate === void 0 ? void 0 : onVolumeUpdate(value);
  }, []);
  /* VLCPlayer Callback */


  const _onLoadStart = _react.default.useCallback(() => {
    setLoading(true); // setShowPoster(true);

    showPoster.current = true;
  }, []);

  const _onLoad = _react.default.useCallback(status => {
    console.log(`_onLoad: ${JSON.stringify(status)}`);
    setLoading(false);
    setError(!status.isLoaded);

    if (status.isLoaded) {
      onLoad === null || onLoad === void 0 ? void 0 : onLoad(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? nexenConfig.index : playList === null || playList === void 0 ? void 0 : playList.currentIndex);
      setTrackInfo(prevState => {
        return { ...prevState,
          totalTrackTime: status.durationMillis / 1000
        };
      });

      if (nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.autoPlay) {
        setPaused(false);
      }
    }

    isSeekable.current = status.isLoaded;
    gestureEnabled.current = status.isLoaded;
    isStopped.current = false;
  }, []);

  const _onPlaybackStatusUpdate = _react.default.useCallback(status => {
    if (status.isLoaded) {
      if (status.positionMillis != 0 && showPoster) {
        // setShowPoster(false);
        showPoster.current = false;
      }

      if (!isSeeking.current) {
        setTrackInfo({
          trackTime: status.positionMillis / 1000,
          cachedTrackTime: status.playableDurationMillis / 1000,
          totalTrackTime: status.durationMillis / 1000
        });
      }

      if (!status.isLooping && status.didJustFinish) {
        if (playList) {
          var _playList$items3;

          if (playList.currentIndex < ((_playList$items3 = playList.items) === null || _playList$items3 === void 0 ? void 0 : _playList$items3.length) - 1) {
            _onSkipNext();
          } else {
            handleStopPlayback();
          }
        } else {
          handleStopPlayback();
        }
      }
    }
  }, [showPoster]);

  const _onError = _react.default.useCallback(error => {
    setError(true);
    onError === null || onError === void 0 ? void 0 : onError(error);
  }, []);

  const newSource = playList !== null && playList !== void 0 && playList.items ? (playList === null || playList === void 0 ? void 0 : playList.items.length) !== 0 ? playList === null || playList === void 0 ? void 0 : playList.items[playList.currentIndex].itemSource : nexenSource : nexenSource;

  if (newSource.poster) {
    posterDisabled.current = false;
  } else {
    posterDisabled.current = true;
  }

  const newStyle = fullScreen ? {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
    zIndex: 9999
  } : {
    position: 'relative'
  };
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.playerContainer, style, newStyle],
    onLayout: _onLayoutChange
  }, nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.optimize ? (nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.index) === (nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.activeIndex) ? /*#__PURE__*/_react.default.createElement(_expoAv.Video, {
    ref: videoRef,
    style: styles.player,
    source: newSource.source,
    shouldPlay: !paused,
    isMuted: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.muted,
    volume: (nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.volume) / 100,
    isLooping: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.repeat,
    rate: Number(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.playbackSpeed),
    resizeMode: (0, _StringUtil.getKeyByValue)(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.resizeMode),
    progressUpdateIntervalMillis: 500,
    onLoadStart: _onLoadStart,
    onLoad: _onLoad,
    onPlaybackStatusUpdate: _onPlaybackStatusUpdate,
    onError: _onError
  }) : null : /*#__PURE__*/_react.default.createElement(_expoAv.Video, {
    ref: videoRef,
    style: styles.player,
    source: newSource.source,
    shouldPlay: !paused,
    isMuted: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.muted,
    volume: (nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.volume) / 100,
    isLooping: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.repeat,
    rate: Number(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.playbackSpeed),
    resizeMode: (0, _StringUtil.getKeyByValue)(nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.resizeMode),
    progressUpdateIntervalMillis: 500,
    onLoadStart: _onLoadStart,
    onLoad: _onLoad,
    onPlaybackStatusUpdate: _onPlaybackStatusUpdate,
    onError: _onError
  }), !posterDisabled.current && showPoster.current && !error && /*#__PURE__*/_react.default.createElement(_PosterView.default, {
    posterSource: newSource.poster,
    posterResizeMode: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.posterResizeMode
  }), /*#__PURE__*/_react.default.createElement(_GestureView.default, {
    fullScreen: fullScreen,
    locked: locked,
    error: error,
    isSeeking: isSeeking,
    isSliding: isSliding,
    isSeekable: isSeekable,
    gestureEnabled: gestureEnabled,
    durationTime: durationTime,
    currentTime: currentTime,
    dimension: dimension,
    playerConfig: nexenConfig,
    nexenTheme: nexenTheme,
    onTapDetected: _onTapDetected,
    onGestureMove: _onGestureMove,
    onGestureEnd: _onGestureEnd
  }), /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, showControl && /*#__PURE__*/_react.default.createElement(_HeaderControl.default, {
    ref: headerControlRef,
    title: newSource.title,
    opacity: headerOpacity,
    marginTop: headerTopMargin,
    fullScreen: fullScreen,
    locked: locked,
    insets: insets,
    playerConfig: nexenConfig,
    nexenTheme: nexenTheme,
    onBackPress: _onBackPress,
    onAspectRatioPress: _onAspectRatioPress,
    onMorePress: _onMorePress
  }), showControl && /*#__PURE__*/_react.default.createElement(_FooterControl.default, {
    ref: footerControlRef,
    opacity: footerOpacity,
    marginBottom: footerBottomMargin,
    fullScreen: fullScreen,
    locked: locked,
    insets: insets,
    playerConfig: nexenConfig,
    nexenTheme: nexenTheme,
    paused: paused,
    isSeekable: isSeekable,
    isVolumeSeekable: isVolumeSeekable,
    trackTime: trackInfo.trackTime,
    cachedTrackTime: trackInfo.cachedTrackTime,
    totalTrackTime: trackInfo.totalTrackTime,
    totalVolume: _GestureView.MAX_VOLUME,
    disablePlaylistAndSkip: disablePlaylistAndSkip,
    onPlayPress: _onTogglePlayPause,
    onStopPress: _onStopPress,
    onReloadPress: _onReloadPress,
    onFullScreenPress: _onToggleFullScreen,
    onVolumePress: _onToggleVolume,
    onAspectRatioPress: _onAspectRatioPress,
    onRewind: _onRewind,
    onFastForward: _onFastForward,
    onSkipNext: _onSkipNext,
    onSkipBack: _onSkipBack,
    onSeekStart: _onSeekStart,
    onSeekUpdate: _onSeekUpdate,
    onSeekEnd: _onSeekEnd,
    onVolumeSeekStart: _onVolumeSeekStart,
    onVolumeSeekUpdate: _onVolumeSeekUpdate,
    onVolumeSeekEnd: _onVolumeSeekEnd,
    onSlideStart: _onSlideStart,
    onSlideEnd: _onSlideEnd,
    onReachedToStart: _onReachedToStart,
    onReachedToEnd: _onReachedToEnd
  }), !showControl && !showMoreControl && !showSpeedControl && !showPlaylistControl && /*#__PURE__*/_react.default.createElement(_LineSeekBar.default, {
    trackTime: trackInfo.trackTime,
    totalTrackTime: trackInfo.totalTrackTime,
    layoutWidth: dimension.width,
    theme: lineSeekBarTheme
  }), showMoreControl && /*#__PURE__*/_react.default.createElement(_MoreControl.default, {
    ref: moreControlRef,
    animateFrom: 'RIGHT',
    distance: MORE_CONTROL_CONTAINER_WIDTH,
    style: {
      width: MORE_CONTROL_CONTAINER_WIDTH,
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderTopLeftRadius: CONTAINER_BORDER_RADIUS,
      borderBottomLeftRadius: CONTAINER_BORDER_RADIUS
    },
    fullScreen: fullScreen,
    disablePlaylistAndSkip: disablePlaylistAndSkip,
    insets: insets,
    playerConfig: nexenConfig,
    nexenTheme: nexenTheme,
    onItemPress: _onMoreItemPress
  }), showSpeedControl && /*#__PURE__*/_react.default.createElement(_SpeedControl.default, {
    ref: speedControlRef,
    animateFrom: 'BOTTOM',
    distance: SPEED_CONTROL_CONTAINER_HEIGHT,
    style: {
      height: SPEED_CONTROL_CONTAINER_HEIGHT,
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderTopLeftRadius: CONTAINER_BORDER_RADIUS,
      borderTopRightRadius: CONTAINER_BORDER_RADIUS
    },
    fullScreen: fullScreen,
    insets: insets,
    currentSpeed: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.playbackSpeed,
    nexenTheme: nexenTheme,
    onSpeedChange: _onSpeedUpdate
  }), showPlaylistControl && /*#__PURE__*/_react.default.createElement(_PlaylistControl.default, {
    ref: playlistControlRef,
    animateFrom: 'BOTTOM',
    distance: PLAYLIST_CONTROL_CONTAINER_HEIGHT,
    style: {
      height: PLAYLIST_CONTROL_CONTAINER_HEIGHT,
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderTopLeftRadius: CONTAINER_BORDER_RADIUS,
      borderTopRightRadius: CONTAINER_BORDER_RADIUS
    },
    playlist: playList === null || playList === void 0 ? void 0 : playList.items,
    playlistIndex: playList === null || playList === void 0 ? void 0 : playList.currentIndex,
    fullScreen: fullScreen,
    nexenTheme: nexenTheme,
    insets: insets,
    onPlaylistItemPress: _onPlaylistItemPress
  }), paused && !showControl && !showMoreControl && !showSpeedControl && !showPlaylistControl && !loading && !locked && !error && !(nexenConfig !== null && nexenConfig !== void 0 && nexenConfig.disableOnScreenPlayButton) && /*#__PURE__*/_react.default.createElement(_PlayButton.default, {
    dimension: dimension,
    onPlayPress: _onPlayButtonPress
  }), !error && loading && /*#__PURE__*/_react.default.createElement(_Loader.default, {
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    theme: loaderTheme,
    loaderText: nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.loaderText
  }), (nexenConfig === null || nexenConfig === void 0 ? void 0 : nexenConfig.layoutMode) !== 'basic' && /*#__PURE__*/_react.default.createElement(_TipView.default, {
    ref: tipViewRef,
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    theme: tipViewTheme
  })));
});

var _default = NexenPlayer;
exports.default = _default;
NexenPlayer.defaultProps = {
  playList: {
    items: [],
    currentIndex: 0
  },
  insets: {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  }
};

const styles = _reactNative.StyleSheet.create({
  playerContainer: {
    position: 'relative',
    width: '100%',
    height: '100%',
    overflow: 'hidden',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#0a0a0a'
  },
  player: {
    width: '100%',
    height: '100%'
  }
});
//# sourceMappingURL=NexenPlayer.js.map