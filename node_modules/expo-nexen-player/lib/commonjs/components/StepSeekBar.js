"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _MathUtil = require("../utils/MathUtil");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const StepSeekBar = props => {
  const {
    data,
    initialIndex,
    theme,
    style,
    onStepChange
  } = props;

  const [dimensions, setDimensions] = _react.default.useState({
    width: 0,
    height: 0
  });

  const cursorPosition = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const locationX = _react.default.useRef(0);

  const dx = _react.default.useRef(0);

  const isMoving = _react.default.useRef(false);

  const animFinished = _react.default.useRef(true);

  const seekDistance = _react.default.useRef(0);

  const stepThreshold = _react.default.useRef(0);

  const stepWidth = _react.default.useRef(0);

  const rtlMultiplier = _react.default.useRef(1);

  const isRTL = _reactNative.I18nManager.isRTL;
  rtlMultiplier.current = isRTL ? -1 : 1;
  const HORIZONTAL_PADDING = (theme === null || theme === void 0 ? void 0 : theme.thumbSize) / 2;

  const onLayoutChange = async e => {
    const {
      width,
      height
    } = e.nativeEvent.layout;
    const {
      width: w,
      height: h
    } = dimensions;

    if (w !== width || h !== height) {
      setDimensions({
        width,
        height
      });
    }
  };

  _react.default.useEffect(() => {
    seekDistance.current = (dimensions.width - (theme === null || theme === void 0 ? void 0 : theme.thumbSize)) * rtlMultiplier.current;
    stepWidth.current = seekDistance.current / (data.length - 1);
    stepThreshold.current = stepWidth.current / 2;
    calculateInitialStep();
  }, [dimensions]);

  const calculateInitialStep = () => {
    const currentPosition = stepWidth.current * initialIndex;
    locationX.current = currentPosition;
    cursorPosition.setValue(currentPosition);
  };

  const moveTo = (position, callback) => {
    _reactNative.Animated.timing(cursorPosition, {
      toValue: position,
      duration: 200,
      useNativeDriver: false
    }).start(_ref => {
      let {
        finished
      } = _ref;

      if (finished) {
        callback === null || callback === void 0 ? void 0 : callback();
      }
    });
  };

  const jumpTo = (position, callback) => {
    _reactNative.Animated.timing(cursorPosition, {
      toValue: position,
      duration: 100,
      easing: _reactNative.Easing.linear,
      useNativeDriver: false
    }).start(() => {
      callback === null || callback === void 0 ? void 0 : callback();
    });
  };

  const handleComplete = index => {
    if (index >= 0 && index < data.length) {
      const value = data[index];
      onStepChange === null || onStepChange === void 0 ? void 0 : onStepChange(value);
    }
  };

  const panResponder = _react.default.useRef(_reactNative.PanResponder.create({
    onStartShouldSetPanResponder: (e, gestureState) => true,
    onStartShouldSetPanResponderCapture: (e, gestureState) => true,
    onMoveShouldSetPanResponder: (e, gestureState) => true,
    onMoveShouldSetPanResponderCapture: (e, gestureState) => true,
    onPanResponderGrant: (e, gestureState) => {},
    onPanResponderMove: (e, gestureState) => {
      if (dx.current != gestureState.dx) {
        dx.current = gestureState.dx;

        if (isMoving.current) {
          const position = (0, _MathUtil.boundPosition)(locationX.current + dx.current, seekDistance.current);
          cursorPosition.setValue(position);
        } else {
          if (Math.abs(dx.current) > 20) {
            if (animFinished.current) {
              animFinished.current = false;
              dx.current = gestureState.dx;
              const position = (0, _MathUtil.boundPosition)(locationX.current + dx.current, seekDistance.current);
              jumpTo(position, () => {
                isMoving.current = true;
                animFinished.current = true;
              });
            }
          }
        }
      }
    },
    onPanResponderRelease: (e, gestureState) => {
      isMoving.current = false;
      const position = (0, _MathUtil.boundPosition)(locationX.current + dx.current, seekDistance.current);
      locationX.current = position;
      const index = Math.floor(locationX.current / stepWidth.current);
      const remainder = locationX.current % stepWidth.current;

      if (Math.abs(remainder) >= Math.abs(stepThreshold.current)) {
        let nextIndex = index + 1;
        let nextPosition = stepWidth.current * nextIndex;

        if (nextPosition > seekDistance.current) {
          nextIndex = index;
          nextPosition = stepWidth.current * nextIndex;
        }

        locationX.current = nextPosition;
        moveTo(nextPosition, () => {
          handleComplete(nextIndex);
        });
      } else {
        const nextPosition = stepWidth.current * index;
        locationX.current = nextPosition;
        moveTo(nextPosition, () => {
          handleComplete(index);
        });
      }
    },
    onPanResponderTerminationRequest: (e, gestureState) => false,
    onPanResponderTerminate: (e, gestureState) => {},
    onShouldBlockNativeResponder: (evt, gestureState) => {
      return true;
    }
  }));

  const lineStyle = {
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.lineColor,
    height: theme === null || theme === void 0 ? void 0 : theme.lineHeight,
    left: HORIZONTAL_PADDING,
    right: HORIZONTAL_PADDING
  };
  const dotStyle = {
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.dotColor,
    width: theme === null || theme === void 0 ? void 0 : theme.dotSize,
    height: theme === null || theme === void 0 ? void 0 : theme.dotSize,
    borderRadius: theme === null || theme === void 0 ? void 0 : theme.dotCornerRadius
  };
  const cursorStyle = {
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.thumbColor,
    width: theme === null || theme === void 0 ? void 0 : theme.thumbSize,
    height: theme === null || theme === void 0 ? void 0 : theme.thumbSize,
    borderRadius: theme === null || theme === void 0 ? void 0 : theme.thumbCornerRadius,
    transform: [{
      translateX: cursorPosition
    }]
  };
  const textStyle = {
    color: theme === null || theme === void 0 ? void 0 : theme.textColor,
    fontFamily: theme === null || theme === void 0 ? void 0 : theme.font
  };
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.container, style],
    onLayout: onLayoutChange
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: styles.slideContainer
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.line, lineStyle]
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.dotContainer, {
      left: HORIZONTAL_PADDING,
      right: HORIZONTAL_PADDING
    }]
  }, data.map((d, i) => /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    key: i,
    style: [styles.dot, dotStyle]
  }))), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, _extends({
    style: [styles.cursor, cursorStyle]
  }, panResponder.current.panHandlers))), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.textContainer, {
      paddingHorizontal: HORIZONTAL_PADDING / 2
    }]
  }, data.map((d, i) => /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    key: i,
    style: [styles.text, textStyle]
  }, data[i]))));
};

var _default = StepSeekBar;
exports.default = _default;
StepSeekBar.defaultProps = {
  initialIndex: 0
};

const styles = _reactNative.StyleSheet.create({
  container: {
    position: 'relative',
    justifyContent: 'center',
    height: 50
  },
  slideContainer: {
    position: 'relative',
    width: '100%',
    justifyContent: 'center'
  },
  dotContainer: {
    position: 'absolute',
    flexDirection: 'row',
    justifyContent: 'space-between'
  },
  dot: {
    width: 6,
    height: 6,
    borderRadius: 3
  },
  textContainer: {
    width: '100%',
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 10
  },
  text: {
    minWidth: 24,
    fontSize: 12,
    textAlign: 'center'
  },
  line: {
    position: 'absolute',
    height: 2,
    borderRadius: 1
  },
  cursor: {
    width: 16,
    height: 16,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1
    },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
    elevation: 2
  }
});
//# sourceMappingURL=StepSeekBar.js.map