"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _MathUtil = require("../utils/MathUtil");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const SeekBar = props => {
  const {
    disableCachedTrack,
    disableThumbBorder,
    trackValue,
    cachedTrackValue,
    totalTrackValue,
    theme,
    style,
    onSeekStart,
    onSeekUpdate,
    onSeekEnd,
    isSeekable
  } = props;

  const [dimensions, setDimensions] = _react.default.useState({
    width: 0,
    height: 0
  });

  const rtlMultiplier = _react.default.useRef(1);

  const isRTL = _reactNative.I18nManager.isRTL;
  rtlMultiplier.current = isRTL ? -1 : 1;
  const THUMB_BORDER_SIZE = (theme === null || theme === void 0 ? void 0 : theme.thumbSize) + (theme === null || theme === void 0 ? void 0 : theme.thumbBorderWidth);
  const PADDING = THUMB_BORDER_SIZE / 2;

  const duration = _react.default.useRef(0);

  const buffer = _react.default.useRef(0);

  const progress = _react.default.useRef(0);

  const seekableDistance = _react.default.useRef(0);

  const locationX = _react.default.useRef(0);

  const dx = _react.default.useRef(0);

  const seekPosition = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const seekWidth = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const cachedSeekPosition = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const cachedSeekWidth = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const borderOpacity = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const onLayoutChange = async e => {
    const {
      width,
      height
    } = e.nativeEvent.layout;
    const {
      width: w,
      height: h
    } = dimensions;

    if (w !== width || h !== height) {
      setDimensions({
        width,
        height
      });
    }
  };

  _react.default.useEffect(() => {
    seekableDistance.current = (dimensions.width - PADDING * 2) * rtlMultiplier.current;
  }, [dimensions]);

  _react.default.useEffect(() => {
    duration.current = totalTrackValue;
    buffer.current = cachedTrackValue || 0;
    progress.current = trackValue;
    const position = (0, _MathUtil.boundPosition)((0, _MathUtil.trackToSeekValue)(progress.current, duration.current, seekableDistance.current), seekableDistance.current);
    seekPosition.setValue(position);
    seekWidth.setValue(position * rtlMultiplier.current);
    const cachePosition = (0, _MathUtil.boundPosition)((0, _MathUtil.trackToSeekValue)(buffer.current, duration.current, seekableDistance.current), seekableDistance.current);
    cachedSeekPosition.setValue(cachePosition);
    cachedSeekWidth.setValue(cachePosition * rtlMultiplier.current);
  }, [trackValue, cachedTrackValue, totalTrackValue, dimensions]);

  const updateBorderOpacity = value => {
    _reactNative.Animated.timing(borderOpacity, {
      toValue: value,
      duration: 125,
      useNativeDriver: true
    }).start();
  };

  const panResponder = _react.default.useRef(_reactNative.PanResponder.create({
    onStartShouldSetPanResponder: (e, gestureState) => true,
    onMoveShouldSetPanResponder: (e, gestureState) => true,
    onPanResponderGrant: (e, gestureState) => {
      if (!(isSeekable !== null && isSeekable !== void 0 && isSeekable.current)) return;
      const position = (0, _MathUtil.boundPosition)(isRTL ? seekableDistance.current + e.nativeEvent.locationX : e.nativeEvent.locationX, seekableDistance.current);
      seekPosition.setValue(position);
      seekWidth.setValue(position * rtlMultiplier.current);

      if (!disableThumbBorder) {
        updateBorderOpacity(1);
      }

      locationX.current = position;
      dx.current = gestureState.dx;
      onSeekStart === null || onSeekStart === void 0 ? void 0 : onSeekStart((0, _MathUtil.seekToTrackValue)(position, duration.current, seekableDistance.current), duration.current, position);
    },
    onPanResponderMove: (e, gestureState) => {
      if (!(isSeekable !== null && isSeekable !== void 0 && isSeekable.current)) return;

      if (dx.current != gestureState.dx) {
        dx.current = gestureState.dx;
        const position = (0, _MathUtil.boundPosition)(locationX.current + dx.current, seekableDistance.current);
        seekPosition.setValue(position);
        seekWidth.setValue(position * rtlMultiplier.current);
        onSeekUpdate === null || onSeekUpdate === void 0 ? void 0 : onSeekUpdate((0, _MathUtil.seekToTrackValue)(position, duration.current, seekableDistance.current), duration.current, position);
      }
    },
    onPanResponderRelease: (e, gestureState) => {
      if (!(isSeekable !== null && isSeekable !== void 0 && isSeekable.current)) return;

      if (!disableThumbBorder) {
        updateBorderOpacity(0);
      }

      const position = (0, _MathUtil.boundPosition)(locationX.current + dx.current, seekableDistance.current);
      onSeekEnd === null || onSeekEnd === void 0 ? void 0 : onSeekEnd((0, _MathUtil.seekToTrackValue)(position, duration.current, seekableDistance.current), duration.current, position);
    },
    onPanResponderTerminationRequest: (e, gestureState) => false,
    onPanResponderTerminate: (e, gestureState) => {}
  }));

  const thumbContainerStyle = {
    width: THUMB_BORDER_SIZE,
    height: THUMB_BORDER_SIZE,
    transform: [{
      translateX: seekPosition
    }]
  };
  const thumbStyle = {
    height: theme === null || theme === void 0 ? void 0 : theme.thumbSize,
    width: theme === null || theme === void 0 ? void 0 : theme.thumbSize,
    borderRadius: theme === null || theme === void 0 ? void 0 : theme.thumbCornerRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.thumbColor
  };
  const thumbBorderStyle = {
    width: THUMB_BORDER_SIZE,
    height: THUMB_BORDER_SIZE,
    borderRadius: theme === null || theme === void 0 ? void 0 : theme.thumbBorderCornerRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.thumbBorderColor,
    opacity: borderOpacity
  };
  const totalSeekBarStyle = {
    left: PADDING,
    right: PADDING,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.totalTrackColor,
    height: theme === null || theme === void 0 ? void 0 : theme.trackHeight,
    borderRadius: (theme === null || theme === void 0 ? void 0 : theme.trackHeight) / 2
  };
  const seekBarStyle = {
    left: PADDING,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.trackColor,
    width: seekWidth,
    height: theme === null || theme === void 0 ? void 0 : theme.trackHeight,
    borderRadius: (theme === null || theme === void 0 ? void 0 : theme.trackHeight) / 2
  };
  const cachedBarStyle = {
    left: PADDING,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.cachedTrackColor,
    width: cachedSeekWidth,
    height: theme === null || theme === void 0 ? void 0 : theme.trackHeight,
    borderRadius: (theme === null || theme === void 0 ? void 0 : theme.trackHeight) / 2
  };
  return /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({
    style: [styles.container, style],
    onLayout: onLayoutChange
  }, panResponder.current.panHandlers), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.totalSeekBar, totalSeekBarStyle]
  }), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: [styles.seekBar, seekBarStyle] // pointerEvents="none"

  }), !disableCachedTrack && /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: [styles.cachedBar, cachedBarStyle] // pointerEvents="none"

  }), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: [styles.thumbContainer, thumbContainerStyle],
    pointerEvents: "none"
  }, !disableThumbBorder && /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
    style: [styles.thumbBorder, thumbBorderStyle]
  }), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [thumbStyle]
  })));
};

var _default = SeekBar;
exports.default = _default;
SeekBar.defaultProps = {
  disableCachedTrack: false,
  disableThumbBorder: false,
  thumbSize: 10,
  thumbBorderWidth: 5,
  thumbRadius: 5,
  thumbBorderRadius: 7.5,
  seekBarHeight: 2
};

const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    position: 'relative',
    justifyContent: 'center'
  },
  thumbContainer: {
    zIndex: 40,
    alignSelf: 'baseline',
    justifyContent: 'center',
    alignItems: 'center'
  },
  thumbBorder: {
    position: 'absolute',
    backgroundColor: 'rgba(250,250,250,0.7)'
  },
  totalSeekBar: {
    zIndex: 10,
    height: 2,
    borderRadius: 1,
    position: 'absolute',
    backgroundColor: 'rgba(250,250,250,0.3)'
  },
  seekBar: {
    zIndex: 30,
    height: 2,
    borderRadius: 1,
    position: 'absolute',
    backgroundColor: '#fa5005'
  },
  cachedBar: {
    zIndex: 20,
    height: 2,
    borderRadius: 1,
    position: 'absolute',
    backgroundColor: '#fafafa'
  }
});
//# sourceMappingURL=SeekBar.js.map