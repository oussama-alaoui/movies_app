"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TapEventType = exports.MAX_VOLUME = exports.MAX_BRIGHTNESS = exports.GestureEventType = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _RippleView = _interopRequireDefault(require("./RippleView"));

var _icons = require("../assets/icons");

var _SeekBarTipView = _interopRequireDefault(require("./SeekBarTipView"));

var _TipView = _interopRequireDefault(require("./TipView"));

var _ErrorView = _interopRequireDefault(require("./ErrorView"));

var _MathUtil = require("../utils/MathUtil");

var _StringUtil = require("../utils/StringUtil");

var _ColorUtil = require("../utils/ColorUtil");

var _ComponentUtil = require("../utils/ComponentUtil");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const FORWARD_OR_REWIND_DURATION = 10;
const BAR_HEIGHT_PERCENTAGE = 0.35;
const MAX_VOLUME = 100;
exports.MAX_VOLUME = MAX_VOLUME;
const MAX_BRIGHTNESS = 100;
exports.MAX_BRIGHTNESS = MAX_BRIGHTNESS;
let GestureEventType;
exports.GestureEventType = GestureEventType;

(function (GestureEventType) {
  GestureEventType["TRACK"] = "TRACK";
  GestureEventType["VOLUME"] = "VOLUME";
  GestureEventType["BRIGHTNESS"] = "BRIGHTNESS";
})(GestureEventType || (exports.GestureEventType = GestureEventType = {}));

let TapEventType;
exports.TapEventType = TapEventType;

(function (TapEventType) {
  TapEventType["SINGLE_TAP"] = "SINGLE_TAP";
  TapEventType["DOUBLE_TAP"] = "DOUBLE_TAP";
  TapEventType["DOUBLE_TAP_LEFT"] = "DOUBLE_TAP_LEFT";
  TapEventType["DOUBLE_TAP_RIGHT"] = "DOUBLE_TAP_RIGHT";
  TapEventType["DOUBLE_TAP_MIDDLE"] = "DOUBLE_TAP_MIDDLE";
})(TapEventType || (exports.TapEventType = TapEventType = {}));

const GestureView = props => {
  var _nexenTheme$sizes, _nexenTheme$colors, _nexenTheme$colors2, _nexenTheme$colors3, _nexenTheme$sizes2;

  const {
    style,
    fullScreen,
    locked,
    error,
    isSeeking,
    isSliding,
    isSeekable,
    gestureEnabled,
    dimension,
    currentTime,
    durationTime,
    playerConfig,
    nexenTheme,
    onTapDetected,
    onGestureMove,
    onGestureEnd
  } = props;

  const tapTimeoutRef = _react.default.useRef(null);

  const volumeBarHeight = _react.default.useRef(new _reactNative.Animated.Value(70)).current;

  const brightnessBarHeight = _react.default.useRef(new _reactNative.Animated.Value(0)).current;

  const seekVolume = _react.default.useRef(0);

  const seekVolumeDy = _react.default.useRef(0);

  const seekBrightness = _react.default.useRef(0);

  const seekBrightnessDy = _react.default.useRef(0);

  const locationX = _react.default.useRef(0);

  const locationY = _react.default.useRef(0);

  const dx = _react.default.useRef(0);

  const dy = _react.default.useRef(0);

  const storeDx = _react.default.useRef([]);

  const storeDy = _react.default.useRef([]);

  const layoutSize = _react.default.useRef({
    width: 0,
    height: 0
  });

  const leftBound = _react.default.useRef(0);

  const rightBound = _react.default.useRef(0);

  const trackFactor = _react.default.useRef(1);

  const volumeFactor = _react.default.useRef(1);

  const brightnessFactor = _react.default.useRef(1);

  const activeGesture = _react.default.useRef('');

  const tipViewRef = _react.default.useRef(null);

  const leftRippleViewRef = _react.default.useRef(null);

  const rightRippleViewRef = _react.default.useRef(null);

  const volumeTipViewRef = _react.default.useRef(null);

  const brightnessTipViewRef = _react.default.useRef(null);

  const minTime = _react.default.useRef(0);

  const maxTime = _react.default.useRef(0);

  const symbol = _react.default.useRef('');

  const layoutOption = _react.default.useRef(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode);

  const RIPPLE_ICON_SIZE = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes = nexenTheme.sizes) === null || _nexenTheme$sizes === void 0 ? void 0 : _nexenTheme$sizes.rippleIconSize;
  const RIPPLE_ICON_COLOR = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors = nexenTheme.colors) === null || _nexenTheme$colors === void 0 ? void 0 : _nexenTheme$colors.rippleIconColor;
  const CONTAINER_BACKGROUND_COLOR = (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors2 = nexenTheme.colors) === null || _nexenTheme$colors2 === void 0 ? void 0 : _nexenTheme$colors2.modalBackgroundColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors3 = nexenTheme.colors) === null || _nexenTheme$colors3 === void 0 ? void 0 : _nexenTheme$colors3.primaryColor, 0.7);
  const CONTAINER_BORDER_RADIUS = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes2 = nexenTheme.sizes) === null || _nexenTheme$sizes2 === void 0 ? void 0 : _nexenTheme$sizes2.modalCornerRadius;

  const rtlMultiplier = _react.default.useRef(1);

  const isRTL = _reactNative.I18nManager.isRTL;
  rtlMultiplier.current = isRTL ? -1 : 1;

  const volumeBarTheme = _react.default.useMemo(() => {
    var _nexenTheme$fonts, _nexenTheme$volumeSee, _nexenTheme$colors4, _nexenTheme$volumeSee2, _nexenTheme$colors5, _nexenTheme$tagView, _nexenTheme$colors6, _nexenTheme$tagView2, _nexenTheme$sizes3, _nexenTheme$sizes4, _nexenTheme$tagView3, _nexenTheme$colors7;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts = nexenTheme.fonts) === null || _nexenTheme$fonts === void 0 ? void 0 : _nexenTheme$fonts.secondaryFont,
      barColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee === void 0 ? void 0 : _nexenTheme$volumeSee.barColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors4 = nexenTheme.colors) === null || _nexenTheme$colors4 === void 0 ? void 0 : _nexenTheme$colors4.secondaryColor, 0.8),
      underlayColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee2 = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee2 === void 0 ? void 0 : _nexenTheme$volumeSee2.underlayColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors5 = nexenTheme.colors) === null || _nexenTheme$colors5 === void 0 ? void 0 : _nexenTheme$colors5.primaryColor, 0.3),
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView = nexenTheme.tagView) === null || _nexenTheme$tagView === void 0 ? void 0 : _nexenTheme$tagView.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors6 = nexenTheme.colors) === null || _nexenTheme$colors6 === void 0 ? void 0 : _nexenTheme$colors6.secondaryTextColor),
      textSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView2 = nexenTheme.tagView) === null || _nexenTheme$tagView2 === void 0 ? void 0 : _nexenTheme$tagView2.textSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes3 = nexenTheme.sizes) === null || _nexenTheme$sizes3 === void 0 ? void 0 : _nexenTheme$sizes3.secondaryTextSize),
      iconSize: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes4 = nexenTheme.sizes) === null || _nexenTheme$sizes4 === void 0 ? void 0 : _nexenTheme$sizes4.secondaryIconSize,
      iconColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView3 = nexenTheme.tagView) === null || _nexenTheme$tagView3 === void 0 ? void 0 : _nexenTheme$tagView3.iconColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors7 = nexenTheme.colors) === null || _nexenTheme$colors7 === void 0 ? void 0 : _nexenTheme$colors7.secondaryIconColor)
    };
  }, [nexenTheme, fullScreen]);

  const brightnessBarTheme = _react.default.useMemo(() => {
    var _nexenTheme$fonts2, _nexenTheme$volumeSee3, _nexenTheme$colors8, _nexenTheme$volumeSee4, _nexenTheme$colors9, _nexenTheme$tagView4, _nexenTheme$colors10, _nexenTheme$tagView5, _nexenTheme$sizes5, _nexenTheme$tagView6, _nexenTheme$sizes6, _nexenTheme$tagView7, _nexenTheme$colors11;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts2 = nexenTheme.fonts) === null || _nexenTheme$fonts2 === void 0 ? void 0 : _nexenTheme$fonts2.secondaryFont,
      barColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee3 = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee3 === void 0 ? void 0 : _nexenTheme$volumeSee3.barColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors8 = nexenTheme.colors) === null || _nexenTheme$colors8 === void 0 ? void 0 : _nexenTheme$colors8.secondaryColor, 0.8),
      underlayColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee4 = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee4 === void 0 ? void 0 : _nexenTheme$volumeSee4.underlayColor) || (0, _ColorUtil.getAlphaColor)(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors9 = nexenTheme.colors) === null || _nexenTheme$colors9 === void 0 ? void 0 : _nexenTheme$colors9.primaryColor, 0.3),
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView4 = nexenTheme.tagView) === null || _nexenTheme$tagView4 === void 0 ? void 0 : _nexenTheme$tagView4.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors10 = nexenTheme.colors) === null || _nexenTheme$colors10 === void 0 ? void 0 : _nexenTheme$colors10.secondaryTextColor),
      textSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView5 = nexenTheme.tagView) === null || _nexenTheme$tagView5 === void 0 ? void 0 : _nexenTheme$tagView5.textSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes5 = nexenTheme.sizes) === null || _nexenTheme$sizes5 === void 0 ? void 0 : _nexenTheme$sizes5.secondaryTextSize),
      iconSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView6 = nexenTheme.tagView) === null || _nexenTheme$tagView6 === void 0 ? void 0 : _nexenTheme$tagView6.iconSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes6 = nexenTheme.sizes) === null || _nexenTheme$sizes6 === void 0 ? void 0 : _nexenTheme$sizes6.secondaryIconSize),
      iconColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView7 = nexenTheme.tagView) === null || _nexenTheme$tagView7 === void 0 ? void 0 : _nexenTheme$tagView7.iconColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors11 = nexenTheme.colors) === null || _nexenTheme$colors11 === void 0 ? void 0 : _nexenTheme$colors11.secondaryIconColor)
    };
  }, [nexenTheme, fullScreen]);

  const tipViewTheme = _react.default.useMemo(() => {
    var _nexenTheme$fonts3, _nexenTheme$tipView, _nexenTheme$colors12, _nexenTheme$tipView2, _nexenTheme$sizes7;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts3 = nexenTheme.fonts) === null || _nexenTheme$fonts3 === void 0 ? void 0 : _nexenTheme$fonts3.secondaryFont,
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView = nexenTheme.tipView) === null || _nexenTheme$tipView === void 0 ? void 0 : _nexenTheme$tipView.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors12 = nexenTheme.colors) === null || _nexenTheme$colors12 === void 0 ? void 0 : _nexenTheme$colors12.secondaryTextColor),
      textSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView2 = nexenTheme.tipView) === null || _nexenTheme$tipView2 === void 0 ? void 0 : _nexenTheme$tipView2.textSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes7 = nexenTheme.sizes) === null || _nexenTheme$sizes7 === void 0 ? void 0 : _nexenTheme$sizes7.secondaryTextSize)
    };
  }, [nexenTheme, fullScreen]);

  const errorTheme = _react.default.useMemo(() => {
    var _nexenTheme$fonts4, _nexenTheme$tipView3, _nexenTheme$colors13, _nexenTheme$tipView4, _nexenTheme$colors14;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts4 = nexenTheme.fonts) === null || _nexenTheme$fonts4 === void 0 ? void 0 : _nexenTheme$fonts4.secondaryFont,
      iconSize: 40,
      iconColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView3 = nexenTheme.tipView) === null || _nexenTheme$tipView3 === void 0 ? void 0 : _nexenTheme$tipView3.iconColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors13 = nexenTheme.colors) === null || _nexenTheme$colors13 === void 0 ? void 0 : _nexenTheme$colors13.secondaryIconColor),
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView4 = nexenTheme.tipView) === null || _nexenTheme$tipView4 === void 0 ? void 0 : _nexenTheme$tipView4.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors14 = nexenTheme.colors) === null || _nexenTheme$colors14 === void 0 ? void 0 : _nexenTheme$colors14.secondaryTextColor),
      textSize: 16
    };
  }, [nexenTheme]);

  _react.default.useEffect(() => {
    layoutOption.current = playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode;
  }, [playerConfig]);

  _react.default.useEffect(() => {
    var _volumeTipViewRef$cur, _brightnessTipViewRef;

    const {
      width,
      height
    } = dimension;
    layoutSize.current = {
      width,
      height
    };
    leftBound.current = width * rtlMultiplier.current / 4;
    rightBound.current = width * rtlMultiplier.current - leftBound.current;
    trackFactor.current = width / 60;
    volumeFactor.current = height / (height * BAR_HEIGHT_PERCENTAGE);
    brightnessFactor.current = height / (height * BAR_HEIGHT_PERCENTAGE);
    seekVolume.current = (0, _MathUtil.clamp)((0, _MathUtil.originalToSeekValue)(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.volume, MAX_VOLUME, height * BAR_HEIGHT_PERCENTAGE), 0, height * BAR_HEIGHT_PERCENTAGE);
    (_volumeTipViewRef$cur = volumeTipViewRef.current) === null || _volumeTipViewRef$cur === void 0 ? void 0 : _volumeTipViewRef$cur.updateState({
      tipText: `${playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.volume}%`,
      icon: (0, _ComponentUtil.getVolumeIcon)(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.volume, MAX_VOLUME, volumeBarTheme.iconSize, volumeBarTheme.iconColor)
    });
    volumeBarHeight.setValue(seekVolume.current);
    seekBrightness.current = (0, _MathUtil.clamp)((0, _MathUtil.originalToSeekValue)(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.brightness, MAX_BRIGHTNESS, height * BAR_HEIGHT_PERCENTAGE) + seekBrightnessDy.current, 0, height * BAR_HEIGHT_PERCENTAGE);
    (_brightnessTipViewRef = brightnessTipViewRef.current) === null || _brightnessTipViewRef === void 0 ? void 0 : _brightnessTipViewRef.updateState({
      tipText: `${playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.brightness}%`,
      icon: (0, _ComponentUtil.getBrightnessIcon)(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.brightness, MAX_BRIGHTNESS, brightnessBarTheme.iconSize, brightnessBarTheme.iconColor)
    });
    brightnessBarHeight.setValue(seekBrightness.current);
  }, [playerConfig, dimension]);

  _react.default.useEffect(() => {
    return () => {
      if (tapTimeoutRef.current) {
        clearTimeout(tapTimeoutRef.current);
      }
    };
  }, []);

  const calculateMinMaxTime = (forwardOrRewindTime, time, totalTime) => {
    if (forwardOrRewindTime >= 0) {
      symbol.current = '+';

      if (forwardOrRewindTime + time >= totalTime) {
        maxTime.current = totalTime;
        minTime.current = totalTime - time;
      } else {
        maxTime.current = forwardOrRewindTime + time;
        minTime.current = forwardOrRewindTime;
      }
    } else {
      symbol.current = '-';

      if (forwardOrRewindTime + time >= 0) {
        maxTime.current = time + forwardOrRewindTime;
        minTime.current = forwardOrRewindTime;
      } else {
        maxTime.current = 0;
        minTime.current = -time;
      }
    }
  };

  const handleDoubleTapForward = () => {
    var _rightRippleViewRef$c;

    const time = currentTime.current + FORWARD_OR_REWIND_DURATION;
    (_rightRippleViewRef$c = rightRippleViewRef.current) === null || _rightRippleViewRef$c === void 0 ? void 0 : _rightRippleViewRef$c.onPress((0, _StringUtil.getForOrRewTimeTipText)('+', FORWARD_OR_REWIND_DURATION, time));
    onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP_RIGHT, time);
  };

  const handleDoubleTapRewind = () => {
    var _leftRippleViewRef$cu;

    const time = currentTime.current - FORWARD_OR_REWIND_DURATION;
    (_leftRippleViewRef$cu = leftRippleViewRef.current) === null || _leftRippleViewRef$cu === void 0 ? void 0 : _leftRippleViewRef$cu.onPress((0, _StringUtil.getForOrRewTimeTipText)('-', FORWARD_OR_REWIND_DURATION, time));
    onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP_LEFT, time);
  };

  const onScreenTouch = event => {
    const {
      locationX
    } = event.nativeEvent;

    if (tapTimeoutRef.current) {
      clearTimeout(tapTimeoutRef.current);
      tapTimeoutRef.current = null;
      if (!gestureEnabled.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) === 'basic' || locked) return;
      onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP);

      if (locationX * rtlMultiplier.current < leftBound.current) {
        handleDoubleTapRewind();
      } else if (locationX * rtlMultiplier.current > rightBound.current) {
        handleDoubleTapForward();
      } else {
        onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP_MIDDLE);
      } // if (showControl) {
      //   if (controlHideOption && controlHideOption == 'auto') {
      //     resetControlTimeout();
      //   }
      // }

    } else {
      tapTimeoutRef.current = setTimeout(() => {
        onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.SINGLE_TAP);
        tapTimeoutRef.current = null;
      }, playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.doubleTapTime);
    }
  };

  const panResponder = _react.default.useRef(_reactNative.PanResponder.create({
    onStartShouldSetPanResponder: (e, gestureState) => true,
    onStartShouldSetPanResponderCapture: (e, gestureState) => false,
    onMoveShouldSetPanResponder: (e, gestureState) => {
      if (isSeeking.current || isSliding.current) {
        return false;
      }

      return Math.abs(gestureState.dx) > 2 || Math.abs(gestureState.dy) > 2;
    },
    onMoveShouldSetPanResponderCapture: (e, gestureState) => {
      if (isSeeking.current || isSliding.current) {
        return false;
      }

      return Math.abs(gestureState.dx) > 2 || Math.abs(gestureState.dy) > 2; // return  || ;
    },
    onPanResponderGrant: (e, gestureState) => {
      if (!gestureEnabled.current || !isSeekable.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) !== 'advanced') return;
      locationX.current = e.nativeEvent.locationX;
      locationY.current = e.nativeEvent.locationY;
    },
    onPanResponderMove: (e, gestureState) => {
      if (!gestureEnabled.current || !isSeekable.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) !== 'advanced') return;

      if (dx.current !== gestureState.dx || dy.current !== gestureState.dy) {
        dx.current = gestureState.dx;
        dy.current = gestureState.dy;

        if (storeDx.current.length < 5) {
          storeDx.current.push(gestureState.dx);
          storeDy.current.push(gestureState.dy);
        }

        if (storeDx.current.length === 5) {
          if (Math.abs(storeDx.current[4] - storeDx.current[0]) > Math.abs(storeDy.current[4] - storeDy.current[0])) {
            if (!(locationX.current + dx.current > 0) || !(locationX.current + dx.current < layoutSize.current.width)) return;

            if (activeGesture.current === '' || activeGesture.current === 'track') {
              var _tipViewRef$current;

              activeGesture.current = 'track';
              calculateMinMaxTime(Math.floor(gestureState.dx * rtlMultiplier.current / trackFactor.current), Math.floor(currentTime.current), Math.floor(durationTime.current));
              (_tipViewRef$current = tipViewRef.current) === null || _tipViewRef$current === void 0 ? void 0 : _tipViewRef$current.updateState({
                showTip: true,
                tipText: (0, _StringUtil.getForwardOrRewindTimeTipText)(symbol.current, Math.floor(minTime.current), Math.floor(maxTime.current)),
                autoHide: false
              });
            }
          } else {
            if (!(locationY.current + dy.current >= 0) || !(locationY.current + dy.current <= layoutSize.current.height)) return;

            if (e.nativeEvent.locationX * rtlMultiplier.current < layoutSize.current.width * rtlMultiplier.current / 2) {
              if (activeGesture.current === '' || activeGesture.current === 'brightness') {
                activeGesture.current = 'brightness';

                if (gestureState.dy >= 0) {
                  var _brightnessTipViewRef2;

                  seekBrightnessDy.current = -Math.round(gestureState.dy / brightnessFactor.current);
                  const boundHeight = (0, _MathUtil.clamp)(seekBrightness.current + seekBrightnessDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalBrightness = (0, _MathUtil.seekToOriginalValue)(boundHeight, MAX_BRIGHTNESS, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_brightnessTipViewRef2 = brightnessTipViewRef.current) === null || _brightnessTipViewRef2 === void 0 ? void 0 : _brightnessTipViewRef2.updateState({
                    showTip: true,
                    tipText: `${originalBrightness}%`,
                    icon: (0, _ComponentUtil.getBrightnessIcon)(originalBrightness, MAX_BRIGHTNESS, brightnessBarTheme.iconSize, brightnessBarTheme.iconColor)
                  });
                  brightnessBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.BRIGHTNESS, originalBrightness);
                } else {
                  var _brightnessTipViewRef3;

                  seekBrightnessDy.current = Math.round(Math.abs(gestureState.dy) / brightnessFactor.current);
                  const boundHeight = (0, _MathUtil.clamp)(seekBrightness.current + seekBrightnessDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalBrightness = (0, _MathUtil.seekToOriginalValue)(boundHeight, MAX_BRIGHTNESS, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_brightnessTipViewRef3 = brightnessTipViewRef.current) === null || _brightnessTipViewRef3 === void 0 ? void 0 : _brightnessTipViewRef3.updateState({
                    showTip: true,
                    tipText: `${originalBrightness}%`,
                    icon: (0, _ComponentUtil.getBrightnessIcon)(originalBrightness, MAX_BRIGHTNESS, brightnessBarTheme.iconSize, brightnessBarTheme.iconColor)
                  });
                  brightnessBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.BRIGHTNESS, originalBrightness);
                }
              }
            } else {
              if (activeGesture.current === '' || activeGesture.current === 'volume') {
                activeGesture.current = 'volume';

                if (gestureState.dy >= 0) {
                  var _volumeTipViewRef$cur2;

                  seekVolumeDy.current = -Math.round(gestureState.dy / volumeFactor.current);
                  const boundHeight = (0, _MathUtil.clamp)(seekVolume.current + seekVolumeDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalVolume = (0, _MathUtil.seekToOriginalValue)(boundHeight, MAX_VOLUME, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_volumeTipViewRef$cur2 = volumeTipViewRef.current) === null || _volumeTipViewRef$cur2 === void 0 ? void 0 : _volumeTipViewRef$cur2.updateState({
                    showTip: true,
                    tipText: `${originalVolume}%`,
                    icon: (0, _ComponentUtil.getVolumeIcon)(originalVolume, MAX_VOLUME, volumeBarTheme.iconSize, volumeBarTheme.iconColor)
                  });
                  volumeBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.VOLUME, originalVolume);
                } else {
                  var _volumeTipViewRef$cur3;

                  seekVolumeDy.current = Math.round(Math.abs(gestureState.dy) / volumeFactor.current);
                  const boundHeight = (0, _MathUtil.clamp)(seekVolume.current + seekVolumeDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalVolume = (0, _MathUtil.seekToOriginalValue)(boundHeight, MAX_VOLUME, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_volumeTipViewRef$cur3 = volumeTipViewRef.current) === null || _volumeTipViewRef$cur3 === void 0 ? void 0 : _volumeTipViewRef$cur3.updateState({
                    showTip: true,
                    tipText: `${originalVolume}%`,
                    icon: (0, _ComponentUtil.getVolumeIcon)(originalVolume, MAX_VOLUME, volumeBarTheme.iconSize, volumeBarTheme.iconColor)
                  });
                  volumeBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.VOLUME, originalVolume);
                }
              }
            }
          }
        }
      }
    },
    onPanResponderRelease: (e, gestureState) => {
      if (!gestureEnabled.current || !isSeekable.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) !== 'advanced') return;

      if (activeGesture.current === 'track') {
        var _tipViewRef$current2;

        const time = currentTime.current + minTime.current;
        onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd(GestureEventType.TRACK, time);
        (_tipViewRef$current2 = tipViewRef.current) === null || _tipViewRef$current2 === void 0 ? void 0 : _tipViewRef$current2.updateState({
          showTip: false,
          autoHide: true
        });
      } else if (activeGesture.current === 'volume') {
        var _volumeTipViewRef$cur4;

        (_volumeTipViewRef$cur4 = volumeTipViewRef.current) === null || _volumeTipViewRef$cur4 === void 0 ? void 0 : _volumeTipViewRef$cur4.updateState({
          showTip: false,
          tipText: ''
        });
        const boundHeight = (0, _MathUtil.clamp)(seekVolume.current + seekVolumeDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        seekVolume.current = boundHeight;
        const originalVolume = (0, _MathUtil.seekToOriginalValue)(boundHeight, MAX_VOLUME, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd(GestureEventType.VOLUME, originalVolume);
      } else {
        var _brightnessTipViewRef4;

        (_brightnessTipViewRef4 = brightnessTipViewRef.current) === null || _brightnessTipViewRef4 === void 0 ? void 0 : _brightnessTipViewRef4.updateState({
          showTip: false,
          tipText: ''
        });
        const boundHeight = (0, _MathUtil.clamp)(seekBrightness.current + seekBrightnessDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        seekBrightness.current = boundHeight;
        const originalBrightness = (0, _MathUtil.seekToOriginalValue)(boundHeight, MAX_BRIGHTNESS, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd(GestureEventType.BRIGHTNESS, originalBrightness);
      }

      activeGesture.current = '';
      storeDx.current = [];
      storeDy.current = [];
    },
    onPanResponderTerminationRequest: (e, gestureState) => true,
    onPanResponderTerminate: (e, gestureState) => {},
    onShouldBlockNativeResponder: (e, gestureState) => true
  }));

  return /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({
    style: [styles.container, style]
  }, panResponder.current.panHandlers), /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
    style: styles.innerContainer,
    activeOpacity: 1,
    onPress: onScreenTouch
  }, (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/_react.default.createElement(_RippleView.default, {
    ref: leftRippleViewRef,
    style: {
      position: 'absolute',
      left: 0,
      top: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    rippleStyle: {
      right: 0
    },
    rippleSize: dimension.height / 2
  }, /*#__PURE__*/_react.default.createElement(_icons.IconRewind, {
    style: {
      transform: [{
        scaleX: isRTL ? -1 : 1
      }]
    },
    size: RIPPLE_ICON_SIZE,
    color: RIPPLE_ICON_COLOR
  })), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/_react.default.createElement(_RippleView.default, {
    ref: rightRippleViewRef,
    style: {
      position: 'absolute',
      top: 0,
      right: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    rippleStyle: {
      left: 0
    },
    rippleSize: dimension.height / 2
  }, /*#__PURE__*/_react.default.createElement(_icons.IconFastForward, {
    style: {
      transform: [{
        scaleX: isRTL ? -1 : 1
      }]
    },
    size: RIPPLE_ICON_SIZE,
    color: RIPPLE_ICON_COLOR
  })), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/_react.default.createElement(_SeekBarTipView.default, {
    ref: volumeTipViewRef,
    parentStyle: {
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    dimension: dimension,
    barHeight: volumeBarHeight,
    heightPercentage: BAR_HEIGHT_PERCENTAGE,
    icon: /*#__PURE__*/_react.default.createElement(_icons.IconVolume2, {
      size: volumeBarTheme.iconSize,
      color: volumeBarTheme.iconColor
    }),
    theme: volumeBarTheme
  }), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/_react.default.createElement(_SeekBarTipView.default, {
    ref: brightnessTipViewRef,
    parentStyle: {
      position: 'absolute',
      top: 0,
      right: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    dimension: dimension,
    barHeight: brightnessBarHeight,
    heightPercentage: BAR_HEIGHT_PERCENTAGE,
    icon: /*#__PURE__*/_react.default.createElement(_icons.IconSun, {
      size: brightnessBarTheme.iconSize,
      color: brightnessBarTheme.iconColor
    }),
    theme: brightnessBarTheme
  }), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/_react.default.createElement(_TipView.default, {
    ref: tipViewRef,
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    theme: tipViewTheme
  }), error && /*#__PURE__*/_react.default.createElement(_ErrorView.default, {
    style: {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      backgroundColor: CONTAINER_BACKGROUND_COLOR
    },
    theme: errorTheme,
    errorText: playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.errorText
  })));
};

var _default = /*#__PURE__*/_react.default.memo(GestureView);

exports.default = _default;

const styles = _reactNative.StyleSheet.create({
  container: {
    position: 'absolute',
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  },
  innerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
//# sourceMappingURL=GestureView.js.map