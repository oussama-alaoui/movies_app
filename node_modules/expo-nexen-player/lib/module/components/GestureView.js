function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import { Animated, I18nManager, PanResponder, StyleSheet, TouchableOpacity, View } from 'react-native';
import RippleView from './RippleView';
import { IconFastForward, IconRewind, IconSun, IconVolume2 } from '../assets/icons';
import SeekBarTipView from './SeekBarTipView';
import TipView from './TipView';
import ErrorView from './ErrorView';
import { clamp, originalToSeekValue, seekToOriginalValue } from '../utils/MathUtil';
import { getForOrRewTimeTipText, getForwardOrRewindTimeTipText } from '../utils/StringUtil';
import { getAlphaColor } from '../utils/ColorUtil';
import { getBrightnessIcon, getVolumeIcon } from '../utils/ComponentUtil';
const FORWARD_OR_REWIND_DURATION = 10;
const BAR_HEIGHT_PERCENTAGE = 0.35;
export const MAX_VOLUME = 100;
export const MAX_BRIGHTNESS = 100;
export let GestureEventType;

(function (GestureEventType) {
  GestureEventType["TRACK"] = "TRACK";
  GestureEventType["VOLUME"] = "VOLUME";
  GestureEventType["BRIGHTNESS"] = "BRIGHTNESS";
})(GestureEventType || (GestureEventType = {}));

export let TapEventType;

(function (TapEventType) {
  TapEventType["SINGLE_TAP"] = "SINGLE_TAP";
  TapEventType["DOUBLE_TAP"] = "DOUBLE_TAP";
  TapEventType["DOUBLE_TAP_LEFT"] = "DOUBLE_TAP_LEFT";
  TapEventType["DOUBLE_TAP_RIGHT"] = "DOUBLE_TAP_RIGHT";
  TapEventType["DOUBLE_TAP_MIDDLE"] = "DOUBLE_TAP_MIDDLE";
})(TapEventType || (TapEventType = {}));

const GestureView = props => {
  var _nexenTheme$sizes, _nexenTheme$colors, _nexenTheme$colors2, _nexenTheme$colors3, _nexenTheme$sizes2;

  const {
    style,
    fullScreen,
    locked,
    error,
    isSeeking,
    isSliding,
    isSeekable,
    gestureEnabled,
    dimension,
    currentTime,
    durationTime,
    playerConfig,
    nexenTheme,
    onTapDetected,
    onGestureMove,
    onGestureEnd
  } = props;
  const tapTimeoutRef = React.useRef(null);
  const volumeBarHeight = React.useRef(new Animated.Value(70)).current;
  const brightnessBarHeight = React.useRef(new Animated.Value(0)).current;
  const seekVolume = React.useRef(0);
  const seekVolumeDy = React.useRef(0);
  const seekBrightness = React.useRef(0);
  const seekBrightnessDy = React.useRef(0);
  const locationX = React.useRef(0);
  const locationY = React.useRef(0);
  const dx = React.useRef(0);
  const dy = React.useRef(0);
  const storeDx = React.useRef([]);
  const storeDy = React.useRef([]);
  const layoutSize = React.useRef({
    width: 0,
    height: 0
  });
  const leftBound = React.useRef(0);
  const rightBound = React.useRef(0);
  const trackFactor = React.useRef(1);
  const volumeFactor = React.useRef(1);
  const brightnessFactor = React.useRef(1);
  const activeGesture = React.useRef('');
  const tipViewRef = React.useRef(null);
  const leftRippleViewRef = React.useRef(null);
  const rightRippleViewRef = React.useRef(null);
  const volumeTipViewRef = React.useRef(null);
  const brightnessTipViewRef = React.useRef(null);
  const minTime = React.useRef(0);
  const maxTime = React.useRef(0);
  const symbol = React.useRef('');
  const layoutOption = React.useRef(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode);
  const RIPPLE_ICON_SIZE = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes = nexenTheme.sizes) === null || _nexenTheme$sizes === void 0 ? void 0 : _nexenTheme$sizes.rippleIconSize;
  const RIPPLE_ICON_COLOR = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors = nexenTheme.colors) === null || _nexenTheme$colors === void 0 ? void 0 : _nexenTheme$colors.rippleIconColor;
  const CONTAINER_BACKGROUND_COLOR = (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors2 = nexenTheme.colors) === null || _nexenTheme$colors2 === void 0 ? void 0 : _nexenTheme$colors2.modalBackgroundColor) || getAlphaColor(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors3 = nexenTheme.colors) === null || _nexenTheme$colors3 === void 0 ? void 0 : _nexenTheme$colors3.primaryColor, 0.7);
  const CONTAINER_BORDER_RADIUS = nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes2 = nexenTheme.sizes) === null || _nexenTheme$sizes2 === void 0 ? void 0 : _nexenTheme$sizes2.modalCornerRadius;
  const rtlMultiplier = React.useRef(1);
  const isRTL = I18nManager.isRTL;
  rtlMultiplier.current = isRTL ? -1 : 1;
  const volumeBarTheme = React.useMemo(() => {
    var _nexenTheme$fonts, _nexenTheme$volumeSee, _nexenTheme$colors4, _nexenTheme$volumeSee2, _nexenTheme$colors5, _nexenTheme$tagView, _nexenTheme$colors6, _nexenTheme$tagView2, _nexenTheme$sizes3, _nexenTheme$sizes4, _nexenTheme$tagView3, _nexenTheme$colors7;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts = nexenTheme.fonts) === null || _nexenTheme$fonts === void 0 ? void 0 : _nexenTheme$fonts.secondaryFont,
      barColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee === void 0 ? void 0 : _nexenTheme$volumeSee.barColor) || getAlphaColor(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors4 = nexenTheme.colors) === null || _nexenTheme$colors4 === void 0 ? void 0 : _nexenTheme$colors4.secondaryColor, 0.8),
      underlayColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee2 = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee2 === void 0 ? void 0 : _nexenTheme$volumeSee2.underlayColor) || getAlphaColor(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors5 = nexenTheme.colors) === null || _nexenTheme$colors5 === void 0 ? void 0 : _nexenTheme$colors5.primaryColor, 0.3),
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView = nexenTheme.tagView) === null || _nexenTheme$tagView === void 0 ? void 0 : _nexenTheme$tagView.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors6 = nexenTheme.colors) === null || _nexenTheme$colors6 === void 0 ? void 0 : _nexenTheme$colors6.secondaryTextColor),
      textSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView2 = nexenTheme.tagView) === null || _nexenTheme$tagView2 === void 0 ? void 0 : _nexenTheme$tagView2.textSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes3 = nexenTheme.sizes) === null || _nexenTheme$sizes3 === void 0 ? void 0 : _nexenTheme$sizes3.secondaryTextSize),
      iconSize: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes4 = nexenTheme.sizes) === null || _nexenTheme$sizes4 === void 0 ? void 0 : _nexenTheme$sizes4.secondaryIconSize,
      iconColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView3 = nexenTheme.tagView) === null || _nexenTheme$tagView3 === void 0 ? void 0 : _nexenTheme$tagView3.iconColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors7 = nexenTheme.colors) === null || _nexenTheme$colors7 === void 0 ? void 0 : _nexenTheme$colors7.secondaryIconColor)
    };
  }, [nexenTheme, fullScreen]);
  const brightnessBarTheme = React.useMemo(() => {
    var _nexenTheme$fonts2, _nexenTheme$volumeSee3, _nexenTheme$colors8, _nexenTheme$volumeSee4, _nexenTheme$colors9, _nexenTheme$tagView4, _nexenTheme$colors10, _nexenTheme$tagView5, _nexenTheme$sizes5, _nexenTheme$tagView6, _nexenTheme$sizes6, _nexenTheme$tagView7, _nexenTheme$colors11;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts2 = nexenTheme.fonts) === null || _nexenTheme$fonts2 === void 0 ? void 0 : _nexenTheme$fonts2.secondaryFont,
      barColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee3 = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee3 === void 0 ? void 0 : _nexenTheme$volumeSee3.barColor) || getAlphaColor(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors8 = nexenTheme.colors) === null || _nexenTheme$colors8 === void 0 ? void 0 : _nexenTheme$colors8.secondaryColor, 0.8),
      underlayColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$volumeSee4 = nexenTheme.volumeSeekBar) === null || _nexenTheme$volumeSee4 === void 0 ? void 0 : _nexenTheme$volumeSee4.underlayColor) || getAlphaColor(nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors9 = nexenTheme.colors) === null || _nexenTheme$colors9 === void 0 ? void 0 : _nexenTheme$colors9.primaryColor, 0.3),
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView4 = nexenTheme.tagView) === null || _nexenTheme$tagView4 === void 0 ? void 0 : _nexenTheme$tagView4.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors10 = nexenTheme.colors) === null || _nexenTheme$colors10 === void 0 ? void 0 : _nexenTheme$colors10.secondaryTextColor),
      textSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView5 = nexenTheme.tagView) === null || _nexenTheme$tagView5 === void 0 ? void 0 : _nexenTheme$tagView5.textSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes5 = nexenTheme.sizes) === null || _nexenTheme$sizes5 === void 0 ? void 0 : _nexenTheme$sizes5.secondaryTextSize),
      iconSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView6 = nexenTheme.tagView) === null || _nexenTheme$tagView6 === void 0 ? void 0 : _nexenTheme$tagView6.iconSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes6 = nexenTheme.sizes) === null || _nexenTheme$sizes6 === void 0 ? void 0 : _nexenTheme$sizes6.secondaryIconSize),
      iconColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tagView7 = nexenTheme.tagView) === null || _nexenTheme$tagView7 === void 0 ? void 0 : _nexenTheme$tagView7.iconColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors11 = nexenTheme.colors) === null || _nexenTheme$colors11 === void 0 ? void 0 : _nexenTheme$colors11.secondaryIconColor)
    };
  }, [nexenTheme, fullScreen]);
  const tipViewTheme = React.useMemo(() => {
    var _nexenTheme$fonts3, _nexenTheme$tipView, _nexenTheme$colors12, _nexenTheme$tipView2, _nexenTheme$sizes7;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts3 = nexenTheme.fonts) === null || _nexenTheme$fonts3 === void 0 ? void 0 : _nexenTheme$fonts3.secondaryFont,
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView = nexenTheme.tipView) === null || _nexenTheme$tipView === void 0 ? void 0 : _nexenTheme$tipView.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors12 = nexenTheme.colors) === null || _nexenTheme$colors12 === void 0 ? void 0 : _nexenTheme$colors12.secondaryTextColor),
      textSize: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView2 = nexenTheme.tipView) === null || _nexenTheme$tipView2 === void 0 ? void 0 : _nexenTheme$tipView2.textSize) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$sizes7 = nexenTheme.sizes) === null || _nexenTheme$sizes7 === void 0 ? void 0 : _nexenTheme$sizes7.secondaryTextSize)
    };
  }, [nexenTheme, fullScreen]);
  const errorTheme = React.useMemo(() => {
    var _nexenTheme$fonts4, _nexenTheme$tipView3, _nexenTheme$colors13, _nexenTheme$tipView4, _nexenTheme$colors14;

    return {
      font: nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$fonts4 = nexenTheme.fonts) === null || _nexenTheme$fonts4 === void 0 ? void 0 : _nexenTheme$fonts4.secondaryFont,
      iconSize: 40,
      iconColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView3 = nexenTheme.tipView) === null || _nexenTheme$tipView3 === void 0 ? void 0 : _nexenTheme$tipView3.iconColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors13 = nexenTheme.colors) === null || _nexenTheme$colors13 === void 0 ? void 0 : _nexenTheme$colors13.secondaryIconColor),
      textColor: (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$tipView4 = nexenTheme.tipView) === null || _nexenTheme$tipView4 === void 0 ? void 0 : _nexenTheme$tipView4.textColor) || (nexenTheme === null || nexenTheme === void 0 ? void 0 : (_nexenTheme$colors14 = nexenTheme.colors) === null || _nexenTheme$colors14 === void 0 ? void 0 : _nexenTheme$colors14.secondaryTextColor),
      textSize: 16
    };
  }, [nexenTheme]);
  React.useEffect(() => {
    layoutOption.current = playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode;
  }, [playerConfig]);
  React.useEffect(() => {
    var _volumeTipViewRef$cur, _brightnessTipViewRef;

    const {
      width,
      height
    } = dimension;
    layoutSize.current = {
      width,
      height
    };
    leftBound.current = width * rtlMultiplier.current / 4;
    rightBound.current = width * rtlMultiplier.current - leftBound.current;
    trackFactor.current = width / 60;
    volumeFactor.current = height / (height * BAR_HEIGHT_PERCENTAGE);
    brightnessFactor.current = height / (height * BAR_HEIGHT_PERCENTAGE);
    seekVolume.current = clamp(originalToSeekValue(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.volume, MAX_VOLUME, height * BAR_HEIGHT_PERCENTAGE), 0, height * BAR_HEIGHT_PERCENTAGE);
    (_volumeTipViewRef$cur = volumeTipViewRef.current) === null || _volumeTipViewRef$cur === void 0 ? void 0 : _volumeTipViewRef$cur.updateState({
      tipText: `${playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.volume}%`,
      icon: getVolumeIcon(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.volume, MAX_VOLUME, volumeBarTheme.iconSize, volumeBarTheme.iconColor)
    });
    volumeBarHeight.setValue(seekVolume.current);
    seekBrightness.current = clamp(originalToSeekValue(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.brightness, MAX_BRIGHTNESS, height * BAR_HEIGHT_PERCENTAGE) + seekBrightnessDy.current, 0, height * BAR_HEIGHT_PERCENTAGE);
    (_brightnessTipViewRef = brightnessTipViewRef.current) === null || _brightnessTipViewRef === void 0 ? void 0 : _brightnessTipViewRef.updateState({
      tipText: `${playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.brightness}%`,
      icon: getBrightnessIcon(playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.brightness, MAX_BRIGHTNESS, brightnessBarTheme.iconSize, brightnessBarTheme.iconColor)
    });
    brightnessBarHeight.setValue(seekBrightness.current);
  }, [playerConfig, dimension]);
  React.useEffect(() => {
    return () => {
      if (tapTimeoutRef.current) {
        clearTimeout(tapTimeoutRef.current);
      }
    };
  }, []);

  const calculateMinMaxTime = (forwardOrRewindTime, time, totalTime) => {
    if (forwardOrRewindTime >= 0) {
      symbol.current = '+';

      if (forwardOrRewindTime + time >= totalTime) {
        maxTime.current = totalTime;
        minTime.current = totalTime - time;
      } else {
        maxTime.current = forwardOrRewindTime + time;
        minTime.current = forwardOrRewindTime;
      }
    } else {
      symbol.current = '-';

      if (forwardOrRewindTime + time >= 0) {
        maxTime.current = time + forwardOrRewindTime;
        minTime.current = forwardOrRewindTime;
      } else {
        maxTime.current = 0;
        minTime.current = -time;
      }
    }
  };

  const handleDoubleTapForward = () => {
    var _rightRippleViewRef$c;

    const time = currentTime.current + FORWARD_OR_REWIND_DURATION;
    (_rightRippleViewRef$c = rightRippleViewRef.current) === null || _rightRippleViewRef$c === void 0 ? void 0 : _rightRippleViewRef$c.onPress(getForOrRewTimeTipText('+', FORWARD_OR_REWIND_DURATION, time));
    onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP_RIGHT, time);
  };

  const handleDoubleTapRewind = () => {
    var _leftRippleViewRef$cu;

    const time = currentTime.current - FORWARD_OR_REWIND_DURATION;
    (_leftRippleViewRef$cu = leftRippleViewRef.current) === null || _leftRippleViewRef$cu === void 0 ? void 0 : _leftRippleViewRef$cu.onPress(getForOrRewTimeTipText('-', FORWARD_OR_REWIND_DURATION, time));
    onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP_LEFT, time);
  };

  const onScreenTouch = event => {
    const {
      locationX
    } = event.nativeEvent;

    if (tapTimeoutRef.current) {
      clearTimeout(tapTimeoutRef.current);
      tapTimeoutRef.current = null;
      if (!gestureEnabled.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) === 'basic' || locked) return;
      onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP);

      if (locationX * rtlMultiplier.current < leftBound.current) {
        handleDoubleTapRewind();
      } else if (locationX * rtlMultiplier.current > rightBound.current) {
        handleDoubleTapForward();
      } else {
        onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.DOUBLE_TAP_MIDDLE);
      } // if (showControl) {
      //   if (controlHideOption && controlHideOption == 'auto') {
      //     resetControlTimeout();
      //   }
      // }

    } else {
      tapTimeoutRef.current = setTimeout(() => {
        onTapDetected === null || onTapDetected === void 0 ? void 0 : onTapDetected(TapEventType.SINGLE_TAP);
        tapTimeoutRef.current = null;
      }, playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.doubleTapTime);
    }
  };

  const panResponder = React.useRef(PanResponder.create({
    onStartShouldSetPanResponder: (e, gestureState) => true,
    onStartShouldSetPanResponderCapture: (e, gestureState) => false,
    onMoveShouldSetPanResponder: (e, gestureState) => {
      if (isSeeking.current || isSliding.current) {
        return false;
      }

      return Math.abs(gestureState.dx) > 2 || Math.abs(gestureState.dy) > 2;
    },
    onMoveShouldSetPanResponderCapture: (e, gestureState) => {
      if (isSeeking.current || isSliding.current) {
        return false;
      }

      return Math.abs(gestureState.dx) > 2 || Math.abs(gestureState.dy) > 2; // return  || ;
    },
    onPanResponderGrant: (e, gestureState) => {
      if (!gestureEnabled.current || !isSeekable.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) !== 'advanced') return;
      locationX.current = e.nativeEvent.locationX;
      locationY.current = e.nativeEvent.locationY;
    },
    onPanResponderMove: (e, gestureState) => {
      if (!gestureEnabled.current || !isSeekable.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) !== 'advanced') return;

      if (dx.current !== gestureState.dx || dy.current !== gestureState.dy) {
        dx.current = gestureState.dx;
        dy.current = gestureState.dy;

        if (storeDx.current.length < 5) {
          storeDx.current.push(gestureState.dx);
          storeDy.current.push(gestureState.dy);
        }

        if (storeDx.current.length === 5) {
          if (Math.abs(storeDx.current[4] - storeDx.current[0]) > Math.abs(storeDy.current[4] - storeDy.current[0])) {
            if (!(locationX.current + dx.current > 0) || !(locationX.current + dx.current < layoutSize.current.width)) return;

            if (activeGesture.current === '' || activeGesture.current === 'track') {
              var _tipViewRef$current;

              activeGesture.current = 'track';
              calculateMinMaxTime(Math.floor(gestureState.dx * rtlMultiplier.current / trackFactor.current), Math.floor(currentTime.current), Math.floor(durationTime.current));
              (_tipViewRef$current = tipViewRef.current) === null || _tipViewRef$current === void 0 ? void 0 : _tipViewRef$current.updateState({
                showTip: true,
                tipText: getForwardOrRewindTimeTipText(symbol.current, Math.floor(minTime.current), Math.floor(maxTime.current)),
                autoHide: false
              });
            }
          } else {
            if (!(locationY.current + dy.current >= 0) || !(locationY.current + dy.current <= layoutSize.current.height)) return;

            if (e.nativeEvent.locationX * rtlMultiplier.current < layoutSize.current.width * rtlMultiplier.current / 2) {
              if (activeGesture.current === '' || activeGesture.current === 'brightness') {
                activeGesture.current = 'brightness';

                if (gestureState.dy >= 0) {
                  var _brightnessTipViewRef2;

                  seekBrightnessDy.current = -Math.round(gestureState.dy / brightnessFactor.current);
                  const boundHeight = clamp(seekBrightness.current + seekBrightnessDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalBrightness = seekToOriginalValue(boundHeight, MAX_BRIGHTNESS, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_brightnessTipViewRef2 = brightnessTipViewRef.current) === null || _brightnessTipViewRef2 === void 0 ? void 0 : _brightnessTipViewRef2.updateState({
                    showTip: true,
                    tipText: `${originalBrightness}%`,
                    icon: getBrightnessIcon(originalBrightness, MAX_BRIGHTNESS, brightnessBarTheme.iconSize, brightnessBarTheme.iconColor)
                  });
                  brightnessBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.BRIGHTNESS, originalBrightness);
                } else {
                  var _brightnessTipViewRef3;

                  seekBrightnessDy.current = Math.round(Math.abs(gestureState.dy) / brightnessFactor.current);
                  const boundHeight = clamp(seekBrightness.current + seekBrightnessDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalBrightness = seekToOriginalValue(boundHeight, MAX_BRIGHTNESS, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_brightnessTipViewRef3 = brightnessTipViewRef.current) === null || _brightnessTipViewRef3 === void 0 ? void 0 : _brightnessTipViewRef3.updateState({
                    showTip: true,
                    tipText: `${originalBrightness}%`,
                    icon: getBrightnessIcon(originalBrightness, MAX_BRIGHTNESS, brightnessBarTheme.iconSize, brightnessBarTheme.iconColor)
                  });
                  brightnessBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.BRIGHTNESS, originalBrightness);
                }
              }
            } else {
              if (activeGesture.current === '' || activeGesture.current === 'volume') {
                activeGesture.current = 'volume';

                if (gestureState.dy >= 0) {
                  var _volumeTipViewRef$cur2;

                  seekVolumeDy.current = -Math.round(gestureState.dy / volumeFactor.current);
                  const boundHeight = clamp(seekVolume.current + seekVolumeDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalVolume = seekToOriginalValue(boundHeight, MAX_VOLUME, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_volumeTipViewRef$cur2 = volumeTipViewRef.current) === null || _volumeTipViewRef$cur2 === void 0 ? void 0 : _volumeTipViewRef$cur2.updateState({
                    showTip: true,
                    tipText: `${originalVolume}%`,
                    icon: getVolumeIcon(originalVolume, MAX_VOLUME, volumeBarTheme.iconSize, volumeBarTheme.iconColor)
                  });
                  volumeBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.VOLUME, originalVolume);
                } else {
                  var _volumeTipViewRef$cur3;

                  seekVolumeDy.current = Math.round(Math.abs(gestureState.dy) / volumeFactor.current);
                  const boundHeight = clamp(seekVolume.current + seekVolumeDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  const originalVolume = seekToOriginalValue(boundHeight, MAX_VOLUME, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
                  (_volumeTipViewRef$cur3 = volumeTipViewRef.current) === null || _volumeTipViewRef$cur3 === void 0 ? void 0 : _volumeTipViewRef$cur3.updateState({
                    showTip: true,
                    tipText: `${originalVolume}%`,
                    icon: getVolumeIcon(originalVolume, MAX_VOLUME, volumeBarTheme.iconSize, volumeBarTheme.iconColor)
                  });
                  volumeBarHeight.setValue(boundHeight);
                  onGestureMove === null || onGestureMove === void 0 ? void 0 : onGestureMove(GestureEventType.VOLUME, originalVolume);
                }
              }
            }
          }
        }
      }
    },
    onPanResponderRelease: (e, gestureState) => {
      if (!gestureEnabled.current || !isSeekable.current || (layoutOption === null || layoutOption === void 0 ? void 0 : layoutOption.current) !== 'advanced') return;

      if (activeGesture.current === 'track') {
        var _tipViewRef$current2;

        const time = currentTime.current + minTime.current;
        onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd(GestureEventType.TRACK, time);
        (_tipViewRef$current2 = tipViewRef.current) === null || _tipViewRef$current2 === void 0 ? void 0 : _tipViewRef$current2.updateState({
          showTip: false,
          autoHide: true
        });
      } else if (activeGesture.current === 'volume') {
        var _volumeTipViewRef$cur4;

        (_volumeTipViewRef$cur4 = volumeTipViewRef.current) === null || _volumeTipViewRef$cur4 === void 0 ? void 0 : _volumeTipViewRef$cur4.updateState({
          showTip: false,
          tipText: ''
        });
        const boundHeight = clamp(seekVolume.current + seekVolumeDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        seekVolume.current = boundHeight;
        const originalVolume = seekToOriginalValue(boundHeight, MAX_VOLUME, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd(GestureEventType.VOLUME, originalVolume);
      } else {
        var _brightnessTipViewRef4;

        (_brightnessTipViewRef4 = brightnessTipViewRef.current) === null || _brightnessTipViewRef4 === void 0 ? void 0 : _brightnessTipViewRef4.updateState({
          showTip: false,
          tipText: ''
        });
        const boundHeight = clamp(seekBrightness.current + seekBrightnessDy.current, 0, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        seekBrightness.current = boundHeight;
        const originalBrightness = seekToOriginalValue(boundHeight, MAX_BRIGHTNESS, layoutSize.current.height * BAR_HEIGHT_PERCENTAGE);
        onGestureEnd === null || onGestureEnd === void 0 ? void 0 : onGestureEnd(GestureEventType.BRIGHTNESS, originalBrightness);
      }

      activeGesture.current = '';
      storeDx.current = [];
      storeDy.current = [];
    },
    onPanResponderTerminationRequest: (e, gestureState) => true,
    onPanResponderTerminate: (e, gestureState) => {},
    onShouldBlockNativeResponder: (e, gestureState) => true
  }));
  return /*#__PURE__*/React.createElement(View, _extends({
    style: [styles.container, style]
  }, panResponder.current.panHandlers), /*#__PURE__*/React.createElement(TouchableOpacity, {
    style: styles.innerContainer,
    activeOpacity: 1,
    onPress: onScreenTouch
  }, (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/React.createElement(RippleView, {
    ref: leftRippleViewRef,
    style: {
      position: 'absolute',
      left: 0,
      top: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    rippleStyle: {
      right: 0
    },
    rippleSize: dimension.height / 2
  }, /*#__PURE__*/React.createElement(IconRewind, {
    style: {
      transform: [{
        scaleX: isRTL ? -1 : 1
      }]
    },
    size: RIPPLE_ICON_SIZE,
    color: RIPPLE_ICON_COLOR
  })), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/React.createElement(RippleView, {
    ref: rightRippleViewRef,
    style: {
      position: 'absolute',
      top: 0,
      right: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    rippleStyle: {
      left: 0
    },
    rippleSize: dimension.height / 2
  }, /*#__PURE__*/React.createElement(IconFastForward, {
    style: {
      transform: [{
        scaleX: isRTL ? -1 : 1
      }]
    },
    size: RIPPLE_ICON_SIZE,
    color: RIPPLE_ICON_COLOR
  })), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/React.createElement(SeekBarTipView, {
    ref: volumeTipViewRef,
    parentStyle: {
      position: 'absolute',
      top: 0,
      left: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    dimension: dimension,
    barHeight: volumeBarHeight,
    heightPercentage: BAR_HEIGHT_PERCENTAGE,
    icon: /*#__PURE__*/React.createElement(IconVolume2, {
      size: volumeBarTheme.iconSize,
      color: volumeBarTheme.iconColor
    }),
    theme: volumeBarTheme
  }), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/React.createElement(SeekBarTipView, {
    ref: brightnessTipViewRef,
    parentStyle: {
      position: 'absolute',
      top: 0,
      right: 0,
      bottom: 0,
      width: dimension.width / 4
    },
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    dimension: dimension,
    barHeight: brightnessBarHeight,
    heightPercentage: BAR_HEIGHT_PERCENTAGE,
    icon: /*#__PURE__*/React.createElement(IconSun, {
      size: brightnessBarTheme.iconSize,
      color: brightnessBarTheme.iconColor
    }),
    theme: brightnessBarTheme
  }), (playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.layoutMode) !== 'basic' && /*#__PURE__*/React.createElement(TipView, {
    ref: tipViewRef,
    style: {
      backgroundColor: CONTAINER_BACKGROUND_COLOR,
      borderRadius: CONTAINER_BORDER_RADIUS
    },
    theme: tipViewTheme
  }), error && /*#__PURE__*/React.createElement(ErrorView, {
    style: {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      backgroundColor: CONTAINER_BACKGROUND_COLOR
    },
    theme: errorTheme,
    errorText: playerConfig === null || playerConfig === void 0 ? void 0 : playerConfig.errorText
  })));
};

export default /*#__PURE__*/React.memo(GestureView);
const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  },
  innerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
//# sourceMappingURL=GestureView.js.map