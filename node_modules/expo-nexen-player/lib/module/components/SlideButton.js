function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import { Animated, I18nManager, PanResponder, StyleSheet, View } from 'react-native';
import { IconLock } from '../assets/icons';
import { boundPosition } from '../utils/MathUtil';

const SlideButton = props => {
  const {
    title,
    width,
    completeThreshold,
    disabled,
    reverseSlideEnabled,
    autoReset,
    autoResetDelay,
    theme,
    onSlideStart,
    onSlideEnd,
    onReachedToStart,
    onReachedToEnd
  } = props;
  const [dimensions, setDimensions] = React.useState({
    width: 0,
    height: 0
  });
  const thumbPosition = React.useRef(new Animated.Value(0)).current;
  const underLayWidth = React.useRef(new Animated.Value(0)).current;
  const textOpacity = React.useRef();
  const slideDistance = React.useRef(0);
  const slideThreshold = React.useRef(0);
  const gestureDisabled = React.useRef(disabled);
  const locationX = React.useRef(0);
  const dx = React.useRef(0);
  const timeoutRef = React.useRef();
  const isRTL = I18nManager.isRTL;
  const rtlMultiplier = isRTL ? -1 : 1;
  let height = (theme === null || theme === void 0 ? void 0 : theme.thumbWidth) + (theme === null || theme === void 0 ? void 0 : theme.padding) * 2;
  let borderRadius = height / 2;
  let childHeight = theme === null || theme === void 0 ? void 0 : theme.thumbHeight;
  const childRadius = theme === null || theme === void 0 ? void 0 : theme.thumbCornerRadius;

  const onLayoutChange = async e => {
    const {
      width,
      height
    } = e.nativeEvent.layout;
    const {
      width: w,
      height: h
    } = dimensions;

    if (w !== width || h !== height) {
      setDimensions({
        width,
        height
      });
    }
  };

  React.useEffect(() => {
    slideDistance.current = (dimensions.width - (theme === null || theme === void 0 ? void 0 : theme.padding) * 2 - (theme === null || theme === void 0 ? void 0 : theme.thumbWidth)) * rtlMultiplier;
    slideThreshold.current = slideDistance.current * (completeThreshold / 100);
  }, [dimensions]);
  React.useEffect(() => {
    gestureDisabled.current = disabled;
  }, [disabled]);
  React.useEffect(() => {
    textOpacity.current = thumbPosition.interpolate({
      inputRange: [-100, 0, 100],
      outputRange: [0.3, 1, 0.3],
      extrapolate: 'clamp'
    });
  }, [thumbPosition]);
  React.useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  const moveTo = (value, complete) => {
    Animated.parallel([Animated.timing(thumbPosition, {
      toValue: value,
      duration: 300,
      useNativeDriver: false
    }), Animated.timing(underLayWidth, {
      toValue: value * rtlMultiplier + (theme === null || theme === void 0 ? void 0 : theme.thumbWidth),
      duration: 300,
      useNativeDriver: false
    })]).start(_ref => {
      let {
        finished
      } = _ref;

      if (finished) {
        handleComplete(complete);
      }
    });
  };

  const reset = () => {
    moveTo(0, false);
    gestureDisabled.current = false;
  };

  const handleComplete = reached => {
    if (reached) {
      onReachedToEnd === null || onReachedToEnd === void 0 ? void 0 : onReachedToEnd();

      if (autoReset) {
        gestureDisabled.current = true;
        timeoutRef.current = setTimeout(() => {
          reset();
        }, autoResetDelay);
      }

      if (!reverseSlideEnabled) {
        gestureDisabled.current = true;
      }
    } else {
      onReachedToStart === null || onReachedToStart === void 0 ? void 0 : onReachedToStart();
    }
  };

  const panResponder = React.useRef(PanResponder.create({
    onStartShouldSetPanResponder: (e, gestureState) => true,
    onMoveShouldSetPanResponder: (e, gestureState) => {
      return true;
    },
    onPanResponderGrant: (e, gestureState) => {
      if (gestureDisabled.current) {
        return;
      }

      onSlideStart === null || onSlideStart === void 0 ? void 0 : onSlideStart();
    },
    onPanResponderMove: (e, gestureState) => {
      if (gestureDisabled.current) {
        return;
      }

      if (dx.current != gestureState.dx) {
        dx.current = gestureState.dx;
        const position = boundPosition(locationX.current + dx.current, slideDistance.current);
        thumbPosition.setValue(position);
        underLayWidth.setValue(position * rtlMultiplier + (theme === null || theme === void 0 ? void 0 : theme.thumbWidth));
      }
    },
    onPanResponderRelease: (e, gestureState) => {
      if (gestureDisabled.current) {
        return;
      }

      locationX.current = locationX.current + dx.current;
      onSlideEnd === null || onSlideEnd === void 0 ? void 0 : onSlideEnd();

      if (isRTL) {
        if (locationX.current > slideThreshold.current) {
          if (locationX.current === 0) {
            handleComplete(false);
            return;
          }

          moveTo(0, false);
          locationX.current = 0;
        } else {
          if (locationX.current === slideDistance.current) {
            handleComplete(true);
            return;
          }

          moveTo(slideDistance.current, true);
          locationX.current = slideDistance.current;
        }
      } else {
        if (locationX.current < slideThreshold.current) {
          if (locationX.current === 0) {
            handleComplete(false);
            return;
          }

          moveTo(0, false);
          locationX.current = 0;
        } else {
          if (locationX.current === slideDistance.current) {
            handleComplete(true);
            return;
          }

          moveTo(slideDistance.current, true);
          locationX.current = slideDistance.current;
        }
      }
    },
    onPanResponderTerminationRequest: (e, gestureState) => false,
    onPanResponderTerminate: (e, gestureState) => {}
  }));
  const containerStyle = {
    width,
    height: height,
    borderRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.containerColor
  };
  const titleContainerStyle = {
    height: childHeight,
    margin: theme === null || theme === void 0 ? void 0 : theme.padding,
    borderRadius: childRadius
  };
  const titleStyle = {
    color: theme === null || theme === void 0 ? void 0 : theme.textColor,
    opacity: textOpacity.current,
    fontFamily: theme === null || theme === void 0 ? void 0 : theme.font
  };
  const underlayStyle = {
    left: theme === null || theme === void 0 ? void 0 : theme.padding,
    width: underLayWidth,
    height: childHeight,
    borderRadius: childRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.underlayColor
  };
  const thumbStyle = {
    left: theme === null || theme === void 0 ? void 0 : theme.padding,
    width: theme === null || theme === void 0 ? void 0 : theme.thumbWidth,
    height: childHeight,
    borderRadius: childRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.thumbColor,
    transform: [{
      translateX: thumbPosition
    }]
  };
  const iconContainerStyle = {
    width: childHeight,
    height: childHeight,
    borderRadius: childRadius,
    transform: [{
      scaleX: isRTL ? -1 : 1
    }]
  };
  return /*#__PURE__*/React.createElement(View, {
    style: [styles.container, containerStyle],
    onLayout: onLayoutChange
  }, /*#__PURE__*/React.createElement(View, {
    style: [styles.titleContainer, titleContainerStyle]
  }, /*#__PURE__*/React.createElement(Animated.Text, {
    numberOfLines: 2,
    allowFontScaling: false,
    style: [styles.title, titleStyle]
  }, title)), /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.underlayContainer, underlayStyle]
  }), /*#__PURE__*/React.createElement(Animated.View, _extends({
    style: [styles.thumbContainer, thumbStyle]
  }, panResponder.current.panHandlers), /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.iconContainer, iconContainerStyle]
  }, /*#__PURE__*/React.createElement(IconLock, {
    size: theme === null || theme === void 0 ? void 0 : theme.thumbIconSize,
    color: theme === null || theme === void 0 ? void 0 : theme.thumbIconColor
  }))));
};

export default SlideButton;
SlideButton.defaultProps = {
  width: '100%',
  padding: 0,
  title: 'Slide to unlock',
  completeThreshold: 60,
  iconSize: 18,
  disabled: false,
  reverseSlideEnabled: true,
  autoReset: false,
  autoResetDelay: 1000,
  onSlideStart: () => {},
  onSlideEnd: () => {},
  onReachedToStart: () => {},
  onReachedToEnd: () => {}
};
const styles = StyleSheet.create({
  container: {
    width: '100%',
    minWidth: 140,
    maxWidth: 220,
    alignSelf: 'center',
    justifyContent: 'center'
  },
  underlayContainer: {
    position: 'absolute'
  },
  titleContainer: {
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 16
  },
  title: {
    fontSize: 14,
    maxWidth: '60%',
    textAlign: 'center'
  },
  thumbContainer: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1
    },
    shadowOpacity: 0.2,
    shadowRadius: 1.41,
    elevation: 2
  },
  iconContainer: {
    justifyContent: 'center',
    alignItems: 'center'
  }
});
//# sourceMappingURL=SlideButton.js.map