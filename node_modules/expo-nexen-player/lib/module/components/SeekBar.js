function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import { Animated, I18nManager, PanResponder, StyleSheet, View } from 'react-native';
import { boundPosition, seekToTrackValue, trackToSeekValue } from '../utils/MathUtil';

const SeekBar = props => {
  const {
    disableCachedTrack,
    disableThumbBorder,
    trackValue,
    cachedTrackValue,
    totalTrackValue,
    theme,
    style,
    onSeekStart,
    onSeekUpdate,
    onSeekEnd,
    isSeekable
  } = props;
  const [dimensions, setDimensions] = React.useState({
    width: 0,
    height: 0
  });
  const rtlMultiplier = React.useRef(1);
  const isRTL = I18nManager.isRTL;
  rtlMultiplier.current = isRTL ? -1 : 1;
  const THUMB_BORDER_SIZE = (theme === null || theme === void 0 ? void 0 : theme.thumbSize) + (theme === null || theme === void 0 ? void 0 : theme.thumbBorderWidth);
  const PADDING = THUMB_BORDER_SIZE / 2;
  const duration = React.useRef(0);
  const buffer = React.useRef(0);
  const progress = React.useRef(0);
  const seekableDistance = React.useRef(0);
  const locationX = React.useRef(0);
  const dx = React.useRef(0);
  const seekPosition = React.useRef(new Animated.Value(0)).current;
  const seekWidth = React.useRef(new Animated.Value(0)).current;
  const cachedSeekPosition = React.useRef(new Animated.Value(0)).current;
  const cachedSeekWidth = React.useRef(new Animated.Value(0)).current;
  const borderOpacity = React.useRef(new Animated.Value(0)).current;

  const onLayoutChange = async e => {
    const {
      width,
      height
    } = e.nativeEvent.layout;
    const {
      width: w,
      height: h
    } = dimensions;

    if (w !== width || h !== height) {
      setDimensions({
        width,
        height
      });
    }
  };

  React.useEffect(() => {
    seekableDistance.current = (dimensions.width - PADDING * 2) * rtlMultiplier.current;
  }, [dimensions]);
  React.useEffect(() => {
    duration.current = totalTrackValue;
    buffer.current = cachedTrackValue || 0;
    progress.current = trackValue;
    const position = boundPosition(trackToSeekValue(progress.current, duration.current, seekableDistance.current), seekableDistance.current);
    seekPosition.setValue(position);
    seekWidth.setValue(position * rtlMultiplier.current);
    const cachePosition = boundPosition(trackToSeekValue(buffer.current, duration.current, seekableDistance.current), seekableDistance.current);
    cachedSeekPosition.setValue(cachePosition);
    cachedSeekWidth.setValue(cachePosition * rtlMultiplier.current);
  }, [trackValue, cachedTrackValue, totalTrackValue, dimensions]);

  const updateBorderOpacity = value => {
    Animated.timing(borderOpacity, {
      toValue: value,
      duration: 125,
      useNativeDriver: true
    }).start();
  };

  const panResponder = React.useRef(PanResponder.create({
    onStartShouldSetPanResponder: (e, gestureState) => true,
    onMoveShouldSetPanResponder: (e, gestureState) => true,
    onPanResponderGrant: (e, gestureState) => {
      if (!(isSeekable !== null && isSeekable !== void 0 && isSeekable.current)) return;
      const position = boundPosition(isRTL ? seekableDistance.current + e.nativeEvent.locationX : e.nativeEvent.locationX, seekableDistance.current);
      seekPosition.setValue(position);
      seekWidth.setValue(position * rtlMultiplier.current);

      if (!disableThumbBorder) {
        updateBorderOpacity(1);
      }

      locationX.current = position;
      dx.current = gestureState.dx;
      onSeekStart === null || onSeekStart === void 0 ? void 0 : onSeekStart(seekToTrackValue(position, duration.current, seekableDistance.current), duration.current, position);
    },
    onPanResponderMove: (e, gestureState) => {
      if (!(isSeekable !== null && isSeekable !== void 0 && isSeekable.current)) return;

      if (dx.current != gestureState.dx) {
        dx.current = gestureState.dx;
        const position = boundPosition(locationX.current + dx.current, seekableDistance.current);
        seekPosition.setValue(position);
        seekWidth.setValue(position * rtlMultiplier.current);
        onSeekUpdate === null || onSeekUpdate === void 0 ? void 0 : onSeekUpdate(seekToTrackValue(position, duration.current, seekableDistance.current), duration.current, position);
      }
    },
    onPanResponderRelease: (e, gestureState) => {
      if (!(isSeekable !== null && isSeekable !== void 0 && isSeekable.current)) return;

      if (!disableThumbBorder) {
        updateBorderOpacity(0);
      }

      const position = boundPosition(locationX.current + dx.current, seekableDistance.current);
      onSeekEnd === null || onSeekEnd === void 0 ? void 0 : onSeekEnd(seekToTrackValue(position, duration.current, seekableDistance.current), duration.current, position);
    },
    onPanResponderTerminationRequest: (e, gestureState) => false,
    onPanResponderTerminate: (e, gestureState) => {}
  }));
  const thumbContainerStyle = {
    width: THUMB_BORDER_SIZE,
    height: THUMB_BORDER_SIZE,
    transform: [{
      translateX: seekPosition
    }]
  };
  const thumbStyle = {
    height: theme === null || theme === void 0 ? void 0 : theme.thumbSize,
    width: theme === null || theme === void 0 ? void 0 : theme.thumbSize,
    borderRadius: theme === null || theme === void 0 ? void 0 : theme.thumbCornerRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.thumbColor
  };
  const thumbBorderStyle = {
    width: THUMB_BORDER_SIZE,
    height: THUMB_BORDER_SIZE,
    borderRadius: theme === null || theme === void 0 ? void 0 : theme.thumbBorderCornerRadius,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.thumbBorderColor,
    opacity: borderOpacity
  };
  const totalSeekBarStyle = {
    left: PADDING,
    right: PADDING,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.totalTrackColor,
    height: theme === null || theme === void 0 ? void 0 : theme.trackHeight,
    borderRadius: (theme === null || theme === void 0 ? void 0 : theme.trackHeight) / 2
  };
  const seekBarStyle = {
    left: PADDING,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.trackColor,
    width: seekWidth,
    height: theme === null || theme === void 0 ? void 0 : theme.trackHeight,
    borderRadius: (theme === null || theme === void 0 ? void 0 : theme.trackHeight) / 2
  };
  const cachedBarStyle = {
    left: PADDING,
    backgroundColor: theme === null || theme === void 0 ? void 0 : theme.cachedTrackColor,
    width: cachedSeekWidth,
    height: theme === null || theme === void 0 ? void 0 : theme.trackHeight,
    borderRadius: (theme === null || theme === void 0 ? void 0 : theme.trackHeight) / 2
  };
  return /*#__PURE__*/React.createElement(View, _extends({
    style: [styles.container, style],
    onLayout: onLayoutChange
  }, panResponder.current.panHandlers), /*#__PURE__*/React.createElement(View, {
    style: [styles.totalSeekBar, totalSeekBarStyle]
  }), /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.seekBar, seekBarStyle] // pointerEvents="none"

  }), !disableCachedTrack && /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.cachedBar, cachedBarStyle] // pointerEvents="none"

  }), /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.thumbContainer, thumbContainerStyle],
    pointerEvents: "none"
  }, !disableThumbBorder && /*#__PURE__*/React.createElement(Animated.View, {
    style: [styles.thumbBorder, thumbBorderStyle]
  }), /*#__PURE__*/React.createElement(View, {
    style: [thumbStyle]
  })));
};

export default SeekBar;
SeekBar.defaultProps = {
  disableCachedTrack: false,
  disableThumbBorder: false,
  thumbSize: 10,
  thumbBorderWidth: 5,
  thumbRadius: 5,
  thumbBorderRadius: 7.5,
  seekBarHeight: 2
};
const styles = StyleSheet.create({
  container: {
    flex: 1,
    position: 'relative',
    justifyContent: 'center'
  },
  thumbContainer: {
    zIndex: 40,
    alignSelf: 'baseline',
    justifyContent: 'center',
    alignItems: 'center'
  },
  thumbBorder: {
    position: 'absolute',
    backgroundColor: 'rgba(250,250,250,0.7)'
  },
  totalSeekBar: {
    zIndex: 10,
    height: 2,
    borderRadius: 1,
    position: 'absolute',
    backgroundColor: 'rgba(250,250,250,0.3)'
  },
  seekBar: {
    zIndex: 30,
    height: 2,
    borderRadius: 1,
    position: 'absolute',
    backgroundColor: '#fa5005'
  },
  cachedBar: {
    zIndex: 20,
    height: 2,
    borderRadius: 1,
    position: 'absolute',
    backgroundColor: '#fafafa'
  }
});
//# sourceMappingURL=SeekBar.js.map